<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-chapters/chapter-12-bipedal-locomotion-and-balance" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Chapter 12: Bipedal Locomotion and Balance | Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 12: Bipedal Locomotion and Balance | Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="Introduction"><meta data-rh="true" property="og:description" content="Introduction"><link data-rh="true" rel="icon" href="/Physical-AI-Humanoid-Robotics/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"><link data-rh="true" rel="alternate" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance" hreflang="en"><link data-rh="true" rel="alternate" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Chapter 12: Bipedal Locomotion and Balance","item":"https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"}]}</script><link rel="stylesheet" href="/Physical-AI-Humanoid-Robotics/assets/css/styles.f1b00d5d.css">
<script src="/Physical-AI-Humanoid-Robotics/assets/js/runtime~main.f590ba4e.js" defer="defer"></script>
<script src="/Physical-AI-Humanoid-Robotics/assets/js/main.999bb550.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Physical-AI-Humanoid-Robotics/"><div class="navbar__logo"><img src="/Physical-AI-Humanoid-Robotics/img/logo-transparent.png" alt="Physical AI Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Physical-AI-Humanoid-Robotics/img/logo-transparent.png" alt="Physical AI Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Physical AI &amp; Humanoid Robotics</b></a><a class="navbar__item navbar__link" href="/Physical-AI-Humanoid-Robotics/">Textbook</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/muskaanfayyaz/Physical-AI-Humanoid-Robotics" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Physical-AI-Humanoid-Robotics/"><span title="About" class="linkLabel_WmDU">About</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-01-introduction-to-physical-ai"><span title="Weeks 1-2: Foundations" class="categoryLinkLabel_W154">Weeks 1-2: Foundations</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-03-introduction-to-ros2"><span title="Weeks 3-5: ROS 2 Fundamentals" class="categoryLinkLabel_W154">Weeks 3-5: ROS 2 Fundamentals</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-06-physics-simulation-with-gazebo"><span title="Weeks 6-7: Simulation" class="categoryLinkLabel_W154">Weeks 6-7: Simulation</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-08-nvidia-isaac-platform"><span title="Weeks 8-10: NVIDIA Isaac Platform" class="categoryLinkLabel_W154">Weeks 8-10: NVIDIA Isaac Platform</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><span title="Weeks 11-12: Humanoid Development" class="categoryLinkLabel_W154">Weeks 11-12: Humanoid Development</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><span title="Chapter 11: Humanoid Robot Kinematics and Dynamics" class="linkLabel_WmDU">Chapter 11: Humanoid Robot Kinematics and Dynamics</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"><span title="Chapter 12: Bipedal Locomotion and Balance" class="linkLabel_WmDU">Chapter 12: Bipedal Locomotion and Balance</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-13-manipulation-and-grasping"><span title="Chapter 13: Manipulation and Grasping" class="linkLabel_WmDU">Chapter 13: Manipulation and Grasping</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-14-natural-human-robot-interaction"><span title="Chapter 14: Natural Human-Robot Interaction" class="linkLabel_WmDU">Chapter 14: Natural Human-Robot Interaction</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-15-conversational-robotics"><span title="Week 13: Conversational AI" class="categoryLinkLabel_W154">Week 13: Conversational AI</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-16-sim-to-real-transfer"><span title="Final Weeks: Deployment &amp; Capstone" class="categoryLinkLabel_W154">Final Weeks: Deployment &amp; Capstone</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/appendix-a-hardware-setup-guides"><span title="Reference Materials" class="categoryLinkLabel_W154">Reference Materials</span></a></div></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/Physical-AI-Humanoid-Robotics/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Weeks 11-12: Humanoid Development</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Chapter 12: Bipedal Locomotion and Balance</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Chapter 12: Bipedal Locomotion and Balance</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" translate="no">​</a></h2>
<p>Walking on two legs seems effortless to humans, yet it represents one of the most complex challenges in robotics. Every step involves precise coordination of dozens of joints, continuous balance maintenance against gravity and inertial forces, and adaptation to terrain variations. Unlike wheeled robots that enjoy passive stability, bipedal humanoids are inherently unstable systems that must actively control their dynamics to avoid falling.</p>
<p>The challenge of bipedal locomotion combines multiple technical domains: kinematics to position the legs, dynamics to manage forces and accelerations, control theory to stabilize inherently unstable motion, and planning to generate feasible trajectories. A walking robot must simultaneously satisfy kinematic constraints (feet must move along valid trajectories), dynamic constraints (ground reaction forces must keep the robot balanced), and physical limits (joint angles, velocities, torques within bounds).</p>
<p>This chapter explores the fundamental principles and practical techniques that enable humanoid robots to walk. We begin with the biomechanics of walking—the gait cycle phases and how weight transfers between feet. The Zero Moment Point (ZMP) emerges as the central concept for balance analysis, providing a mathematical criterion for stable walking. We examine how to generate walking patterns that maintain ZMP within stable regions, explore advanced concepts like the Capture Point for analyzing dynamic balance, and investigate Model Predictive Control approaches that optimize future motion in real-time.</p>
<p>Understanding bipedal locomotion requires integrating knowledge from previous chapters—kinematics to compute foot and center of mass positions, dynamics to predict forces and torques, and control theory to track desired trajectories while maintaining stability. By mastering these concepts, you&#x27;ll understand both the fundamental principles that govern walking and the practical algorithms that enable real humanoid robots to traverse complex environments.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-concepts">Core Concepts<a href="#core-concepts" class="hash-link" aria-label="Direct link to Core Concepts" title="Direct link to Core Concepts" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-gait-cycle-and-walking-phases">The Gait Cycle and Walking Phases<a href="#the-gait-cycle-and-walking-phases" class="hash-link" aria-label="Direct link to The Gait Cycle and Walking Phases" title="Direct link to The Gait Cycle and Walking Phases" translate="no">​</a></h3>
<p>Human walking follows a repeating pattern called the gait cycle, which begins when one foot contacts the ground and ends when that same foot contacts again. This cycle divides into distinct phases that humanoid robots must replicate to achieve natural, stable walking.</p>
<p>The stance phase occurs while a foot remains in contact with the ground, bearing some or all of the robot&#x27;s weight. It begins at heel strike (initial contact) and continues until toe-off when the foot leaves the ground. During stance, the foot provides support and propulsion. The swing phase describes the period when a foot lifts off, swings forward through the air, and prepares for the next heel strike.</p>
<p>A complete gait cycle for one leg includes one stance and one swing phase, but the two legs operate with offset phases. When the right leg is in stance, the left leg may be in swing, and vice versa. This creates alternating periods of single support (one foot on the ground) and double support (both feet on the ground).</p>
<p>Double support phases occur twice per gait cycle: when the front foot contacts while the rear foot hasn&#x27;t lifted yet, and when the rear foot lifts while the front foot has already landed. During double support, the robot enjoys greater stability since both feet can exert forces on the ground. Weight transfer from one leg to the other happens during these phases.</p>
<p>Single support phases are dynamically more challenging. With only one foot providing support, the robot must precisely control its center of mass trajectory to maintain balance. The supporting leg must provide all vertical support force and any necessary corrective torques. The swing leg&#x27;s motion affects the overall center of mass and creates inertial forces throughout the robot.</p>
<p>Walking velocity determines the relative duration of each phase. Slow walking includes longer double support periods, providing more stable weight transfer. As walking speed increases, double support duration decreases and may vanish entirely during running, where a flight phase with no ground contact appears.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="static-versus-dynamic-balance">Static versus Dynamic Balance<a href="#static-versus-dynamic-balance" class="hash-link" aria-label="Direct link to Static versus Dynamic Balance" title="Direct link to Static versus Dynamic Balance" translate="no">​</a></h3>
<p>The distinction between static and dynamic balance fundamentally shapes walking strategies. Static balance requires the center of mass (CoM) vertical projection to remain within the support polygon—the convex hull of all ground contact points. If this condition holds and the robot remains stationary, it won&#x27;t fall.</p>
<p>For a stationary humanoid with both feet flat on the ground, the support polygon is the rectangular region between and including both feet. As long as the CoM projection stays within this region, the robot can maintain balance without moving. This static stability criterion guides slow, careful walking where the CoM never ventures outside the support polygon.</p>
<p>Dynamic balance permits the CoM projection to temporarily exit the support polygon, provided the robot&#x27;s momentum allows it to return. A walking human constantly violates static balance: during single support, the CoM moves outside the supporting foot&#x27;s area but momentum carries it forward until the other foot lands, re-establishing balance. This dynamic strategy enables faster, more efficient walking.</p>
<p>The inverted pendulum serves as the simplest model of bipedal balance. Imagine a point mass atop a massless rod whose base can move horizontally. If the base remains stationary beneath the mass (or moves slowly), the pendulum stays upright through static balance. If the pendulum tilts forward, the base must accelerate forward to catch it—dynamic balance through motion.</p>
<p>Humanoid walking resembles continuously catching yourself from falling forward. Each step begins with the CoM ahead of the support foot, creating a toppling tendency. The swing leg reaches forward and plants, creating new support before the robot falls. This controlled falling and recovery, repeated cyclically, produces walking.</p>
<p>Understanding this fundamental instability explains why walking control is challenging. Unlike statically stable systems that naturally resist disturbances, bipedal robots require active control every millisecond to prevent falling. Sensor feedback, predictive models, and rapid control response all become essential.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="center-of-mass-and-center-of-pressure">Center of Mass and Center of Pressure<a href="#center-of-mass-and-center-of-pressure" class="hash-link" aria-label="Direct link to Center of Mass and Center of Pressure" title="Direct link to Center of Mass and Center of Pressure" translate="no">​</a></h3>
<p>The center of mass (CoM) represents the average position of the robot&#x27;s mass distribution. For a rigid body, it&#x27;s the point where gravitational force effectively acts. For multi-body systems like humanoids, the overall CoM is the mass-weighted average of individual link centers of mass.</p>
<p>Computing the CoM position requires knowing each link&#x27;s mass and center of mass location:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CoM = (sum over all links i of: m_i * p_i) / (sum over all links i of: m_i)</span><br></span></code></pre></div></div>
<p>where m_i is link i&#x27;s mass and p_i is its center of mass position in world coordinates. Forward kinematics provides each p_i based on current joint angles, making CoM computation straightforward given an accurate model.</p>
<p>The center of pressure (CoP) represents the point on the ground where the resultant contact force effectively acts. For a foot on the ground, distributed pressure across the sole creates forces at many points. The CoP is the weighted average position where a single equivalent force would create the same total force and moment.</p>
<p>Ground reaction forces must support the robot&#x27;s weight and any additional forces from acceleration. The vertical component equals the robot&#x27;s weight plus vertical acceleration (F_z = m * (g + a_z)). Horizontal components balance any horizontal accelerations. The total force vector acts at the CoP.</p>
<p>During double support, each foot exerts forces with its own CoP. The overall CoP lies somewhere between the two feet, shifting from rear to front foot as weight transfers during walking. In single support, the CoP must remain within the supporting foot&#x27;s contact area; if it reaches the foot&#x27;s edge, the foot will rotate and the robot will fall.</p>
<p>The relationship between CoM and CoP determines balance. If the CoM is directly above the CoP and both are stationary, the robot is in static equilibrium. If they differ, gravitational and inertial forces create a moment about the CoP, causing angular acceleration. Walking control manages this relationship to produce stable motion.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="zero-moment-point-the-fundamental-balance-criterion">Zero Moment Point: The Fundamental Balance Criterion<a href="#zero-moment-point-the-fundamental-balance-criterion" class="hash-link" aria-label="Direct link to Zero Moment Point: The Fundamental Balance Criterion" title="Direct link to Zero Moment Point: The Fundamental Balance Criterion" translate="no">​</a></h3>
<p>The Zero Moment Point (ZMP) is perhaps the most important concept in bipedal walking. It provides a mathematical criterion for determining whether a planned walking motion will maintain balance and avoid tipping over. Despite its central role, ZMP is often misunderstood, so we&#x27;ll develop the concept carefully.</p>
<p>Consider a humanoid robot with its feet on the ground. Forces and moments act at the contact points: gravity pulls downward, ground reaction forces push upward, and various moments arise from dynamics. Now imagine a horizontal plane just above the ground surface and ask: is there a point on this plane where the total moment (except the moment about the vertical axis) equals zero?</p>
<p>If such a point exists and lies within the support polygon, it&#x27;s the ZMP. The robot can maintain this motion without tipping. If no such point exists within the support polygon, the robot will begin to rotate about the foot edge—the beginning of a fall.</p>
<p>Mathematically, ZMP represents the point where the sum of moments due to gravity and inertial forces equals zero (excluding yaw moments). Computing ZMP requires the full dynamic state: positions, velocities, and accelerations of all links. The ZMP coordinates (x_zmp, y_zmp) are:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x_zmp = (sum of: m_i * (g + a_zi) * x_i - sum of: m_i * a_xi * z_i) / (sum of: m_i * (g + a_zi))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y_zmp = (sum of: m_i * (g + a_zi) * y_i - sum of: m_i * a_yi * z_i) / (sum of: m_i * (g + a_zi))</span><br></span></code></pre></div></div>
<p>where the sums run over all links, m_i is link mass, (x_i, y_i, z_i) is link CoM position, and (a_xi, a_yi, a_zi) are CoM accelerations.</p>
<p>The ZMP stability criterion states: if the computed ZMP lies strictly within the support polygon, the robot can execute the motion without rotating about foot edges. If ZMP reaches the boundary, the foot is about to rotate. If ZMP falls outside, the robot is already rotating—it&#x27;s falling.</p>
<p>This criterion provides a powerful tool for walking control. By computing the ZMP for planned motions before executing them, we can verify stability. By adjusting motion plans to keep ZMP within safe margins from the support polygon boundary, we ensure stable walking even with modeling errors or disturbances.</p>
<p>ZMP differs subtly from CoP. The CoP is measured directly from ground reaction forces and always lies within the contact area (you can&#x27;t push where you&#x27;re not touching). The ZMP is computed from the robot&#x27;s motion and may theoretically lie outside the support polygon. When ZMP is inside, ZMP equals CoP. When the computed ZMP is outside, the actual CoP is at the support polygon edge nearest to the computed ZMP, and the robot is rotating.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="walking-pattern-generation-using-zmp">Walking Pattern Generation Using ZMP<a href="#walking-pattern-generation-using-zmp" class="hash-link" aria-label="Direct link to Walking Pattern Generation Using ZMP" title="Direct link to Walking Pattern Generation Using ZMP" translate="no">​</a></h3>
<p>With the ZMP criterion in hand, we can generate walking trajectories that maintain balance. The approach involves planning trajectories for key points—typically the CoM and swing foot—such that the resulting ZMP remains within the support polygon throughout the gait cycle.</p>
<p>The planning problem has multiple layers. At the highest level, we specify footstep locations: where each foot should land during walking. These footsteps define the support polygon at each phase of the gait. At the intermediate level, we plan the CoM trajectory that produces acceptable ZMP trajectories for the given footsteps. At the lowest level, we compute full-body joint angles via inverse kinematics that achieve the planned CoM and foot motions.</p>
<p>Simplified models enable tractable planning. The Linear Inverted Pendulum Model (LIPM) treats the robot as a point mass CoM atop massless legs, constrained to move at constant height. Despite severe simplifications, LIPM captures essential walking dynamics and permits analytical solutions.</p>
<p>For LIPM on flat ground with CoM height h, the horizontal dynamics decouple into independent x and y directions. In the x direction:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x_ddot = (g / h) * (x - x_zmp)</span><br></span></code></pre></div></div>
<p>This simple equation relates CoM acceleration to the distance between CoM and ZMP. If we specify a ZMP trajectory x_zmp(t), we can integrate to find the CoM trajectory x(t) that produces it. Alternatively, we can specify a CoM trajectory and compute the resulting ZMP.</p>
<p>Preview control, developed by Kajita and colleagues, uses this relationship to generate CoM trajectories. Given a sequence of future footstep locations (defining ZMP reference positions), preview control computes a smooth CoM trajectory that tracks the ZMP reference while maintaining dynamically consistent motion. The controller looks ahead (previews) future footsteps to begin CoM motion early enough to achieve smooth weight transfer.</p>
<p>Pattern generation typically proceeds in stages:</p>
<ol>
<li class="">Footstep planning: Determine where feet should land based on desired walking direction, velocity, and terrain</li>
<li class="">ZMP reference generation: Create a ZMP trajectory that transitions smoothly from one support polygon to the next</li>
<li class="">CoM trajectory generation: Compute a CoM path that produces the reference ZMP using LIPM dynamics</li>
<li class="">Swing foot trajectory generation: Plan how the swing foot lifts, swings forward, and lands</li>
<li class="">Full-body inverse kinematics: Compute joint angles that achieve the planned CoM, stance foot, and swing foot positions</li>
<li class="">Dynamic filtering: Verify and adjust trajectories to account for full-body dynamics beyond LIPM simplifications</li>
</ol>
<p>This process generates a reference trajectory that satisfies kinematic and dynamic constraints. During execution, feedback control tracks this reference while compensating for modeling errors, disturbances, and terrain irregularities.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="capture-point-and-orbital-stability">Capture Point and Orbital Stability<a href="#capture-point-and-orbital-stability" class="hash-link" aria-label="Direct link to Capture Point and Orbital Stability" title="Direct link to Capture Point and Orbital Stability" translate="no">​</a></h3>
<p>While ZMP provides a local stability criterion for the current instant, the Capture Point (CP) concept addresses the question: if the robot stopped taking steps right now, could it avoid falling? This global stability measure complements ZMP and provides insight into recovery from disturbances.</p>
<p>The Capture Point, also called the Capture Point or Extrapolated Center of Mass (XCoM), represents the point on the ground where the robot must step to come to a complete stop. It accounts for both the current CoM position and its velocity, extrapolating where the CoM&#x27;s momentum will carry it.</p>
<p>For the Linear Inverted Pendulum Model, the Capture Point has a simple formula:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CP = CoM_xy + (CoM_velocity_xy / omega)</span><br></span></code></pre></div></div>
<p>where CoM_xy is the horizontal CoM position, CoM_velocity_xy is horizontal velocity, and omega = sqrt(g/h) is the natural frequency of the inverted pendulum with height h.</p>
<p>If the CP lies within the support polygon, the robot can step to that location and come to rest without falling. If the CP lies outside, the robot cannot stop without taking at least one more step. This provides immediate insight into stability: a robot with CP far outside its support polygon is in danger of falling and needs aggressive recovery actions.</p>
<p>During walking, the CP constantly moves. In the LIPM model, it follows a simple trajectory: it moves exponentially from its initial position toward the ZMP. If the ZMP is fixed, the CP converges to it asymptotically. This behavior forms the basis of orbital stability analysis.</p>
<p>Orbital stability asks whether a walking pattern is inherently stable across multiple steps. A periodic walking gait is orbitally stable if small perturbations decay over subsequent steps rather than growing. The Capture Point provides elegant tools for analyzing orbital stability: a gait is orbitally stable if the CP at the end of one step equals the CP at the beginning of that step in the limit cycle.</p>
<p>The stepping strategy for balance recovery becomes intuitive with CP: step toward the Capture Point. If a disturbance pushes the robot, its CoM velocity changes, shifting the CP. By stepping toward the new CP location, the robot can arrest the disturbance and regain stability. This strategy underlies many push recovery controllers.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="model-predictive-control-for-walking">Model Predictive Control for Walking<a href="#model-predictive-control-for-walking" class="hash-link" aria-label="Direct link to Model Predictive Control for Walking" title="Direct link to Model Predictive Control for Walking" translate="no">​</a></h3>
<p>Model Predictive Control (MPC) offers a powerful framework for walking control that can optimize over multiple future steps while respecting constraints. Rather than following pre-generated trajectories, MPC solves an optimization problem at each control cycle to determine the best control actions given the current state and predictions of future behavior.</p>
<p>The MPC approach involves several key elements:</p>
<ol>
<li class="">Predictive model: A mathematical model (often LIPM) predicts how the robot&#x27;s state will evolve given control inputs</li>
<li class="">Receding horizon: The optimization looks ahead a fixed time window into the future, but only the first control action is executed</li>
<li class="">Cost function: An objective that penalizes deviations from desired behavior (e.g., tracking a reference velocity, minimizing energy)</li>
<li class="">Constraints: Hard limits on ZMP location, foot placement, joint limits, etc.</li>
</ol>
<p>At each control cycle, MPC solves an optimization problem: find the sequence of control inputs over the prediction horizon that minimizes the cost function while satisfying all constraints, given the current measured state. After solving, MPC applies only the first control action, then measures the new state and repeats the optimization.</p>
<p>For walking, control inputs typically include footstep locations and timing, while the state includes CoM position, velocity, and current support configuration. The model predicts how the CoM will move given planned footsteps. The cost function might penalize deviation from a desired walking velocity, excessive ZMP variation, or large control effort.</p>
<p>Formulating walking MPC requires discretizing time into steps and using the LIPM dynamics to relate states across time steps. The ZMP constraint (must remain in support polygon) becomes inequality constraints in the optimization. Footstep constraints (where the robot can feasibly step) add additional inequalities.</p>
<p>MPC provides several advantages over open-loop trajectory generation:</p>
<ul>
<li class="">Adaptability: Re-optimization at each step accounts for disturbances and model errors</li>
<li class="">Constraint handling: Hard constraints ensure feasibility and safety</li>
<li class="">Optimality: The solution optimizes a meaningful objective rather than following heuristics</li>
<li class="">Flexibility: Changing objectives or constraints doesn&#x27;t require redesigning the controller</li>
</ul>
<p>However, MPC demands substantial computation. Each control cycle requires solving a constrained optimization problem, often a quadratic program with dozens of variables and constraints. Real-time implementation requires fast solvers and careful problem formulation to ensure solutions complete within milliseconds.</p>
<p>Recent humanoid robots increasingly use MPC for locomotion, enabled by improved computational hardware and efficient optimization algorithms. The ability to adapt footsteps online, handle uneven terrain, and optimize energy consumption provides significant practical advantages over purely feedforward pattern generation.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="trajectory-generation-for-bipedal-motion">Trajectory Generation for Bipedal Motion<a href="#trajectory-generation-for-bipedal-motion" class="hash-link" aria-label="Direct link to Trajectory Generation for Bipedal Motion" title="Direct link to Trajectory Generation for Bipedal Motion" translate="no">​</a></h3>
<p>Beyond high-level planning of CoM and footsteps, walking requires generating detailed trajectories for all degrees of freedom. These trajectories must satisfy kinematic constraints (feet and pelvis follow planned paths), maintain balance (ZMP within bounds), respect joint limits and velocity limits, and produce smooth, continuous motion.</p>
<p>Swing foot trajectories require particular attention. The foot must lift clear of the ground to avoid tripping, swing forward smoothly to the next footstep location, and land gently to avoid impact forces. Common approaches use polynomial splines or Bezier curves that interpolate between lift-off and landing positions while satisfying velocity and acceleration constraints at endpoints.</p>
<p>A typical swing trajectory has three phases:</p>
<ol>
<li class="">Lift: The foot accelerates upward and forward from its stance position, clearing the ground</li>
<li class="">Swing: The foot moves at roughly constant height while advancing forward</li>
<li class="">Land: The foot decelerates and descends to the landing position, arriving with downward velocity near zero</li>
</ol>
<p>The maximum swing height must exceed expected terrain variations plus a safety margin. Too low risks catching on obstacles; too high wastes energy and time. The forward velocity should roughly match the overall walking speed for smooth motion.</p>
<p>Torso trajectory planning maintains posture and assists balance. Tilting the torso forward during walking shifts the CoM forward, affecting ZMP location. Rotating the torso can compensate for swing leg inertia. However, excessive torso motion appears unnatural and can indicate control problems. Smooth, minimal torso movement while maintaining upright posture generally produces the most efficient walking.</p>
<p>Arm swing provides counterbalance to leg motion and improves efficiency. When the right leg swings forward, the left arm swings forward simultaneously, canceling angular momentum. This reduces the torque required at the stance ankle and torso. While not strictly necessary for balance, arm swing measurably improves walking stability and energy efficiency.</p>
<p>Whole-body trajectory optimization can simultaneously determine all joint trajectories by posing walking as a large-scale optimization problem. The decision variables include all joint angles at discrete time steps. Constraints enforce kinematics, dynamics, collision avoidance, and joint limits. The objective minimizes energy, torque, or tracking error. While computationally expensive, trajectory optimization can produce highly efficient motions for complex scenarios.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="fall-detection-and-recovery">Fall Detection and Recovery<a href="#fall-detection-and-recovery" class="hash-link" aria-label="Direct link to Fall Detection and Recovery" title="Direct link to Fall Detection and Recovery" translate="no">​</a></h3>
<p>Despite careful planning, falls can occur due to unexpected disturbances, model errors, or terrain irregularities. Detecting incipient falls early and executing recovery strategies can prevent actual falls and enable robust walking in challenging environments.</p>
<p>Fall detection analyzes multiple indicators:</p>
<ul>
<li class="">ZMP approaching support polygon boundaries: Indicates loss of balance</li>
<li class="">CoM velocity exceeding safe thresholds: Large momentum makes recovery difficult</li>
<li class="">Capture Point outside support polygon: Impossible to stop without stepping</li>
<li class="">Excessive torso tilt: Suggests rotational instability</li>
<li class="">Joint torques saturating: Indicates inability to generate necessary forces</li>
</ul>
<p>Combining multiple indicators improves reliability. A single indicator might trigger false alarms, but multiple simultaneous warning signs reliably indicate genuine fall risk.</p>
<p>Recovery strategies depend on the fall severity and direction:</p>
<p>For mild imbalance, adjusting the CoM trajectory may suffice. Accelerating the CoM toward the support polygon by leaning or shifting weight can bring the ZMP back within safe bounds. This requires sufficient torque authority and time before the fall progresses.</p>
<p>For moderate imbalance, rapid stepping toward the Capture Point arrests the fall. The controller discards the planned footstep sequence and immediately steps toward the CP, creating new support under the CoM&#x27;s projected trajectory. This strategy can recover from surprisingly large disturbances if executed quickly enough.</p>
<p>For severe falls where recovery is impossible, minimizing impact damage becomes the goal. The robot should lower its CoM to reduce potential energy, protect sensitive components by landing on reinforced areas, and extend limbs to absorb impact over larger areas and longer times.</p>
<p>Proactive balance maintenance reduces fall risk. Maintaining ZMP margins from support polygon boundaries, limiting CoM velocity, avoiding singular leg configurations, and monitoring terrain for upcoming irregularities all help prevent falls before they begin.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="terrain-adaptation">Terrain Adaptation<a href="#terrain-adaptation" class="hash-link" aria-label="Direct link to Terrain Adaptation" title="Direct link to Terrain Adaptation" translate="no">​</a></h3>
<p>Real-world environments present uneven terrain, slopes, stairs, and obstacles that challenge walking systems designed for flat ground. Adapting to terrain variations requires perception, planning, and control capabilities beyond nominal walking.</p>
<p>Terrain perception uses vision systems, lidar, or depth cameras to build maps of the environment. Identifying flat surfaces for foot placement, detecting obstacles to avoid, estimating slope angles, and recognizing features like stairs enable informed footstep planning.</p>
<p>Footstep planning for rough terrain modifies the nominal pattern to place feet on stable, level surfaces. The planner considers reachability (can the robot step there given kinematics?), stability (will the foot have adequate support?), and safety (avoiding edges, unstable surfaces). Search algorithms like A* or RRT find sequences of footsteps that navigate from start to goal while respecting terrain constraints.</p>
<p>Slope walking requires adjusting the stance to maintain balance. On upward slopes, leaning forward shifts the CoM projection forward, keeping it within the support polygon despite the tilted ground. On downward slopes, leaning backward provides the same effect. The torso pitch angle must compensate for the slope angle while maintaining comfortable posture.</p>
<p>Stair climbing combines precise foot placement with increased joint range of motion. The swing leg must lift higher to clear each step. The stance leg must extend more to push the CoM upward. Handholds may provide additional support. Descending stairs is often more challenging than ascending because it requires controlled lowering of the CoM, testing the stance leg&#x27;s eccentric strength and control precision.</p>
<p>Compliant control improves robustness to terrain irregularities. Rather than rigidly tracking planned trajectories, compliant controllers allow some deviation when forces indicate contact with unexpected surfaces. This prevents damage from impacts and enables the robot to adapt locally without high-level replanning.</p>
<p>Online trajectory adaptation updates the walking pattern based on real-time feedback. If the foot lands earlier than expected (terrain higher than estimated), the controller adjusts the CoM trajectory accordingly. If the foot slips, recovery actions activate. If terrain differs significantly from the map, replanning generates new footsteps.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-challenge-of-underactuation">The Challenge of Underactuation<a href="#the-challenge-of-underactuation" class="hash-link" aria-label="Direct link to The Challenge of Underactuation" title="Direct link to The Challenge of Underactuation" translate="no">​</a></h3>
<p>Bipedal walking involves fundamental underactuation: the robot has fewer control inputs than degrees of freedom when considering contact constraints. A humanoid in single support can exert forces through one foot, but the location of this force (the CoP) cannot be controlled arbitrarily—it must lie within the foot&#x27;s contact area.</p>
<p>This underactuation creates a hierarchy of control objectives. The primary objective is maintaining balance; without it, all other goals become irrelevant. Secondary objectives like tracking desired walking velocity or minimizing energy can be pursued only to the extent that they don&#x27;t compromise balance.</p>
<p>Hierarchical control formulations respect this priority structure. Balance constraints are strictly enforced as hard constraints. Trajectory tracking and other objectives are optimized subject to maintaining balance. If conflicts arise, balance always takes precedence.</p>
<p>The unactuated degrees of freedom—particularly the global position and orientation—must be controlled indirectly through their dynamic coupling to actuated joints. Moving the legs affects the CoM location, which affects balance, which determines whether the robot continues walking or falls. This indirect control requires understanding the full-body dynamics and carefully coordinating all joints.</p>
<p>Underactuation also creates vulnerabilities. If a disturbance exceeds the robot&#x27;s ability to compensate through actuated joints alone, falling becomes inevitable. For example, a strong lateral push might drive the CoM beyond the foot&#x27;s medial/lateral range faster than the robot can step to recover. Robust walking requires anticipating and avoiding such situations.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="practical-understanding">Practical Understanding<a href="#practical-understanding" class="hash-link" aria-label="Direct link to Practical Understanding" title="Direct link to Practical Understanding" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="computing-the-zero-moment-point">Computing the Zero Moment Point<a href="#computing-the-zero-moment-point" class="hash-link" aria-label="Direct link to Computing the Zero Moment Point" title="Direct link to Computing the Zero Moment Point" translate="no">​</a></h3>
<p>Implementing ZMP-based walking begins with accurately computing the ZMP from the robot&#x27;s state. While the mathematical formula appears straightforward, practical implementation requires careful attention to coordinate frames, efficient computation, and numerical stability.</p>
<p>The ZMP calculation requires knowing each link&#x27;s mass, center of mass location, and acceleration. Forward kinematics provides positions; differentiating the kinematics gives velocities and accelerations. For real-time implementation, numerical differentiation of encoder positions provides velocity and acceleration estimates, though filtering is necessary to reduce noise.</p>
<p>The computation proceeds in several steps:</p>
<ol>
<li class="">Update forward kinematics for all links given current joint angles</li>
<li class="">Compute or estimate velocities and accelerations (from finite differences or direct measurement)</li>
<li class="">Calculate each link&#x27;s contribution to the ZMP numerator and denominator</li>
<li class="">Sum contributions and divide to get ZMP coordinates</li>
</ol>
<p>Spatial algebra and recursive algorithms improve efficiency. Rather than computing each link independently, recursive approaches propagate velocities and accelerations through the kinematic tree, similar to the recursive Newton-Euler dynamics computation. This reduces complexity from O(n^2) to O(n) for n joints.</p>
<p>The ZMP formula assumes flat horizontal ground. For sloped or uneven terrain, the calculation must be performed in the ground plane&#x27;s coordinate frame rather than a horizontal plane. Transformation matrices rotate the robot&#x27;s state into the appropriate frame before ZMP computation.</p>
<p>Numerical issues can arise when the total vertical force approaches zero (e.g., during jumping). The ZMP formula involves division by the sum of vertical forces; near-zero denominators create numerical instability. Practical implementations add small epsilon values or use alternative stability criteria when vertical forces are small.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="generating-walking-patterns-with-preview-control">Generating Walking Patterns with Preview Control<a href="#generating-walking-patterns-with-preview-control" class="hash-link" aria-label="Direct link to Generating Walking Patterns with Preview Control" title="Direct link to Generating Walking Patterns with Preview Control" translate="no">​</a></h3>
<p>Preview control provides a systematic method for generating CoM trajectories that maintain ZMP within the support polygon. The approach uses a Linear Inverted Pendulum Model and solves an optimal control problem with preview of future ZMP references.</p>
<p>The LIPM dynamics in discrete time relate CoM position at the next time step to the current state and ZMP:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x[k+1] = A * x[k] + B * u[k]</span><br></span></code></pre></div></div>
<p>where x contains CoM position and velocity, u is the ZMP position, and A and B are matrices derived from the continuous-time LIPM dynamics and discretization time step.</p>
<p>The preview controller minimizes a cost function that penalizes deviation from a reference ZMP trajectory and large changes in ZMP:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Cost = sum over k of: (Q * e[k]^2 + R * u[k]^2)</span><br></span></code></pre></div></div>
<p>where e[k] is the ZMP tracking error and Q, R are weighting matrices balancing tracking accuracy against control effort.</p>
<p>The optimal control solution involves feedback from the current state and feedforward from the preview of future reference ZMP values. The control law takes the form:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">u[k] = -K_x * x[k] + K_ref * sum over preview window of: (preview_gain[i] * zmp_ref[k+i])</span><br></span></code></pre></div></div>
<p>Computing the gain matrices requires solving a Riccati equation, which can be done offline for a given set of parameters. During runtime, the controller simply applies the pre-computed gains to the current state and preview window.</p>
<p>Implementing preview control requires:</p>
<ol>
<li class="">Footstep planning to determine support polygon transitions</li>
<li class="">ZMP reference generation that smoothly transitions between footstep centers</li>
<li class="">Setting up the LIPM model with appropriate CoM height and discretization time</li>
<li class="">Tuning Q and R matrices to balance tracking versus smoothness</li>
<li class="">Choosing preview window length (longer preview smooths motion but requires more computation)</li>
<li class="">Computing gain matrices offline</li>
<li class="">Running the controller in real-time with state feedback</li>
</ol>
<p>The generated CoM trajectory maintains ZMP close to the reference while producing smooth, dynamically consistent motion. However, LIPM simplifications mean the actual full-body ZMP may differ from predictions. Feedback control during execution compensates for these model errors.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="footstep-planning-fundamentals">Footstep Planning Fundamentals<a href="#footstep-planning-fundamentals" class="hash-link" aria-label="Direct link to Footstep Planning Fundamentals" title="Direct link to Footstep Planning Fundamentals" translate="no">​</a></h3>
<p>Footstep planning determines where the robot should place its feet to walk toward a goal while maintaining balance and avoiding obstacles. This high-level planning layer provides inputs to lower-level trajectory generation.</p>
<p>For straight-line walking on flat ground, footstep planning is straightforward: alternate feet with constant step length and width. Step length typically ranges from 0.1 to 0.5 meters depending on robot size and desired speed. Step width (lateral separation between feet) should be sufficient for stability but not so wide that it wastes energy; typical values range from 0.15 to 0.3 meters.</p>
<p>Turning requires modifying footstep orientation. Each footstep rotates by some fraction of the total desired turn angle. Small turn angles (a few degrees per step) produce smooth turning. Large turn angles risk instability and require slowing the forward walking speed.</p>
<p>For complex environments, footstep planning becomes a search problem. The planner discretizes possible footstep locations into a grid or samples them continuously. Each potential footstep is evaluated for reachability (can kinematics achieve it?), stability (does it provide adequate support polygon?), and collision (does it avoid obstacles?). Graph search algorithms like A* find sequences of valid footsteps from start to goal.</p>
<p>The search state includes foot position, orientation, and which foot is currently in support. Transitions correspond to taking a step: from left support to right support by stepping with the right foot, or vice versa. Costs might include distance traveled, number of steps, energy, or risk.</p>
<p>Heuristics guide the search toward promising regions. The Euclidean distance to goal provides an admissible heuristic. More sophisticated heuristics account for orientation error, expected terrain difficulty, or learned cost-to-go from previous experience.</p>
<p>Footstep planning typically runs slower than real-time since it searches over many possibilities. However, it needs to replan faster than the robot executes steps. If the robot takes 1 second per step, the planner must find a new plan (or verify the existing plan remains valid) within 1 second. Practical implementations often compute plans several steps ahead, then incrementally extend the plan as the robot walks.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="implementing-model-predictive-control">Implementing Model Predictive Control<a href="#implementing-model-predictive-control" class="hash-link" aria-label="Direct link to Implementing Model Predictive Control" title="Direct link to Implementing Model Predictive Control" translate="no">​</a></h3>
<p>MPC for walking solves a quadratic program (QP) at each control cycle to optimize footstep locations and timing. While conceptually straightforward, efficient implementation requires careful problem formulation and choice of solver.</p>
<p>The decision variables typically include footstep locations for several steps ahead (perhaps 3-10 steps) and the state trajectory (CoM position and velocity) at each step. The dynamics constraints link these variables: given footstep locations, the LIPM dynamics determine how CoM evolves.</p>
<p>The cost function might include terms for:</p>
<ul>
<li class="">Velocity tracking: penalize deviation from desired walking velocity</li>
<li class="">Reference tracking: penalize deviation from a reference CoM trajectory</li>
<li class="">Control effort: penalize large footstep adjustments from nominal</li>
<li class="">Regularization: penalize excessive changes from previous solution</li>
</ul>
<p>Constraints include:</p>
<ul>
<li class="">Dynamics: LIPM equations relating states across time steps</li>
<li class="">ZMP stability: ZMP must remain in support polygon</li>
<li class="">Kinematic reachability: footsteps must be within kinematic reach</li>
<li class="">Joint limits: resulting full-body motion must respect joint limits (often simplified or checked post-optimization)</li>
</ul>
<p>The resulting QP has a sparse structure due to the dynamics constraints only coupling adjacent time steps. Exploiting this sparsity dramatically improves solution speed. Specialized QP solvers like qpOASES, OSQP, or Gurobi can solve walking MPCs with dozens of variables in milliseconds.</p>
<p>Warm-starting significantly reduces solution time. Rather than solving from scratch at each control cycle, initialize the optimization with the previous solution shifted forward one time step. Since the problem changes only slightly between cycles, the shifted solution is close to optimal and convergence is rapid.</p>
<p>The MPC formulation must run on the robot&#x27;s onboard computer within the control cycle period, typically 10-50 milliseconds. This requires careful implementation:</p>
<ul>
<li class="">Minimize dynamic memory allocation (allocate buffers once at startup)</li>
<li class="">Use efficient linear algebra libraries (Eigen, BLAS)</li>
<li class="">Exploit problem sparsity</li>
<li class="">Tune solver parameters for speed versus accuracy trade-offs</li>
<li class="">Consider simplified dynamics or reduced horizon if computation is insufficient</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="capture-point-based-stepping-control">Capture Point-Based Stepping Control<a href="#capture-point-based-stepping-control" class="hash-link" aria-label="Direct link to Capture Point-Based Stepping Control" title="Direct link to Capture Point-Based Stepping Control" translate="no">​</a></h3>
<p>The Capture Point provides an intuitive strategy for reactive balance control: when disturbed, step toward the CP. Implementing this strategy requires computing the CP, determining feasible step locations, and coordinating with nominal walking patterns.</p>
<p>Computing the CP from the current state is straightforward using the formula CP = CoM_xy + CoM_velocity_xy / omega. The challenging part is determining where to step. The ideal step location equals the CP, but kinematic constraints, obstacles, and terrain may prevent stepping exactly there.</p>
<p>The feasible stepping region depends on the current support configuration and kinematic limits. For a humanoid in single support on the right foot, the left foot can step within a region determined by leg reach, joint limits, and avoiding self-collision. This region is typically an ellipse or polygon around the current support.</p>
<p>If the CP lies within the feasible region, stepping directly to it arrests the disturbance. If the CP lies outside, stepping to the boundary point closest to the CP provides the best recovery. This may not fully stabilize the robot in one step, but subsequent steps can continue adjusting.</p>
<p>Integrating CP-based stepping with planned walking requires deciding when to abandon the plan and use reactive stepping. Simple strategies use thresholds: if the CP deviates more than some distance from the planned CP, activate reactive stepping. More sophisticated approaches blend nominal and reactive control based on the confidence in the plan and the severity of disturbance.</p>
<p>The timing of reactive steps matters. Immediately stepping upon detecting disturbance provides fastest response but may lead to excessive stepping that interferes with the primary task. Waiting for the next planned step reduces disruption but may allow the disturbance to grow. Adaptive timing based on CP deviation balances these concerns.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="swing-foot-trajectory-generation">Swing Foot Trajectory Generation<a href="#swing-foot-trajectory-generation" class="hash-link" aria-label="Direct link to Swing Foot Trajectory Generation" title="Direct link to Swing Foot Trajectory Generation" translate="no">​</a></h3>
<p>Creating smooth, collision-free swing foot trajectories requires considering multiple objectives: clearing the ground and obstacles, arriving at the target footstep with appropriate orientation and low velocity, and coordinating with the overall gait timing.</p>
<p>Polynomial splines provide a flexible representation. A fifth-order polynomial can independently satisfy position, velocity, and acceleration boundary conditions at both the start and end of the swing phase. The six polynomial coefficients are determined by the six boundary conditions.</p>
<p>For a swing trajectory from (x0, y0, z0) at time t0 to (x1, y1, z1) at time t1, we might specify:</p>
<ul>
<li class="">Initial position: (x0, y0, z0)</li>
<li class="">Initial velocity: zero in z, forward velocity in x, y matching walking speed</li>
<li class="">Final position: (x1, y1, z1)</li>
<li class="">Final velocity: zero in z, forward velocity in x, y matching walking speed</li>
<li class="">Maximum height: z_max occurs at time t_mid = (t0 + t1) / 2</li>
</ul>
<p>The vertical trajectory might use a different polynomial to achieve ground clearance. A simple approach uses a cubic polynomial from z0 to z_max in the first half, then another cubic from z_max to z1 in the second half, ensuring continuous velocity at the midpoint.</p>
<p>Collision checking verifies that the swing trajectory doesn&#x27;t intersect obstacles or the stance leg. If collisions are detected, the trajectory can be adjusted by increasing maximum height, shifting the lateral position, or modifying the timing.</p>
<p>The swing foot orientation typically transitions smoothly from the lift-off orientation to the landing orientation. Quaternion SLERP (spherical linear interpolation) provides smooth rotation interpolation, avoiding the singularities and discontinuities of Euler angle interpolation.</p>
<p>During execution, the swing trajectory serves as a feedforward reference. Feedback control tracks this reference, compensating for modeling errors and disturbances. Impedance control at the ankle allows some compliance during landing, reducing impact forces.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="whole-body-inverse-kinematics-for-walking">Whole-Body Inverse Kinematics for Walking<a href="#whole-body-inverse-kinematics-for-walking" class="hash-link" aria-label="Direct link to Whole-Body Inverse Kinematics for Walking" title="Direct link to Whole-Body Inverse Kinematics for Walking" translate="no">​</a></h3>
<p>With planned trajectories for the CoM, stance foot, and swing foot, inverse kinematics computes joint angles that achieve these Cartesian targets. For walking, this IK problem has multiple constraints that must be satisfied simultaneously.</p>
<p>The constraints typically include:</p>
<ol>
<li class="">Stance foot position and orientation fixed (6 constraints)</li>
<li class="">Swing foot position and orientation following planned trajectory (6 constraints)</li>
<li class="">CoM at planned location (3 constraints)</li>
<li class="">Pelvis orientation upright or at planned angle (3 constraints)</li>
</ol>
<p>A humanoid with 12 leg DOF (6 per leg) has exactly enough degrees of freedom to satisfy these 12-15 constraints. However, the solution may not exist if the constraints are incompatible (e.g., desired CoM too far from stance foot), or multiple solutions may exist.</p>
<p>Formulating this as an optimization problem handles inconsistencies gracefully:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">minimize: sum over constraints i of: w_i * (error_i)^2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">subject to: joint limits</span><br></span></code></pre></div></div>
<p>where w_i are weights prioritizing different constraints. Stance foot constraints typically have very high weight (strict enforcement), while CoM and swing foot constraints might have lower weights allowing small deviations.</p>
<p>The optimization variables are joint angles. The objective measures how well current joint angles satisfy constraints. Gradient-based optimizers like BFGS or sequential quadratic programming can solve this quickly enough for real-time control.</p>
<p>For real-time performance, analytical IK for individual legs can provide initial guesses or even direct solutions. If the pelvis position and orientation are fixed, each leg&#x27;s IK can be solved independently using analytical or numerical methods for 6-DOF manipulators. Then pelvis position can be adjusted to achieve the desired CoM.</p>
<p>Hierarchical IK handles priority levels explicitly. First, solve for joint angles satisfying high-priority constraints (stance foot position). Then, optimize remaining DOF to satisfy lower-priority constraints (swing foot, CoM) using null-space projections that don&#x27;t disturb higher-priority tasks.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="balance-feedback-control">Balance Feedback Control<a href="#balance-feedback-control" class="hash-link" aria-label="Direct link to Balance Feedback Control" title="Direct link to Balance Feedback Control" translate="no">​</a></h3>
<p>Even with perfect planning, model uncertainties and external disturbances require feedback control to maintain balance during walking. Multiple feedback strategies can be combined:</p>
<p>ZMP feedback adjusts the CoM trajectory based on measured ZMP error. If the actual ZMP drifts toward the support polygon boundary, the controller shifts the CoM back toward the polygon center. This can be implemented as a simple proportional controller: CoM_adjustment = K_zmp * (ZMP_desired - ZMP_measured).</p>
<p>Capture Point feedback modifies footstep locations. If the CP deviates from its planned trajectory, the next footstep location is adjusted toward the actual CP. This provides rapid disturbance rejection by directly compensating for momentum errors.</p>
<p>Ankle torque feedback provides immediate response to small disturbances. Tilting the foot adjusts the CoP location within the support foot, providing local balance correction. This is fastest but has limited authority (only effective while the CoP can move within the foot).</p>
<p>Hip torque modulates the torso angle, shifting the CoM horizontally. This provides larger correction authority than ankle torque but is slower to take effect due to greater inertia.</p>
<p>Combining multiple feedback loops creates a cascade of balance controllers operating at different time scales:</p>
<ol>
<li class="">Ankle torque: millisecond response, small authority</li>
<li class="">Hip/torso adjustment: tens of milliseconds, medium authority</li>
<li class="">CoM trajectory modification: hundreds of milliseconds, large authority</li>
<li class="">Footstep adjustment: seconds, largest authority</li>
</ol>
<p>Each level compensates for disturbances within its capability. Small disturbances are handled by fast, local controllers. Large disturbances trigger higher-level adjustments that have greater authority but slower response.</p>
<p>Gain tuning balances responsiveness against oscillation. High gains provide aggressive disturbance rejection but may cause the robot to oscillate. Low gains are stable but allow large tracking errors. Adaptive gains that increase based on error magnitude provide good compromise.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="handling-uneven-terrain">Handling Uneven Terrain<a href="#handling-uneven-terrain" class="hash-link" aria-label="Direct link to Handling Uneven Terrain" title="Direct link to Handling Uneven Terrain" translate="no">​</a></h3>
<p>Walking on uneven terrain requires integrating perception, planning, and control beyond flat-ground capabilities. The process begins with terrain mapping to identify where to step and how to adapt gait.</p>
<p>Terrain mapping uses onboard sensors—cameras, lidar, depth sensors—to build a height map of the environment. Processing identifies flat regions suitable for foot placement, estimates local slope angles, detects obstacles, and assesses surface properties (slippery, compliant, rigid).</p>
<p>Footstep planning on uneven terrain searches for sequences of footholds that are:</p>
<ul>
<li class="">Reachable: within kinematic limits from current stance</li>
<li class="">Stable: large enough and flat enough for secure support</li>
<li class="">Safe: avoiding edges, steep slopes, or unstable surfaces</li>
</ul>
<p>The planner might prefer certain regions (flat, level surfaces) while penalizing others (slopes, small footholds). Path planning algorithms like A* or sampling-based methods explore the space of possible footstep sequences.</p>
<p>Adapting the CoM trajectory for terrain requires accounting for foot height variations. When stepping up onto a higher surface, the CoM must rise accordingly. The LIPM assumption of constant CoM height breaks down, requiring either a variable-height model or transitions between different constant-height models.</p>
<p>Landing on uneven surfaces creates impact uncertainties. The foot might contact earlier or later than expected if height estimates are inaccurate. Compliant control allows the leg to absorb these impacts gracefully. Force sensing at the foot detects contact and triggers transition to stance phase even if timing differs from the plan.</p>
<p>Slope adaptation adjusts body posture to maintain balance on tilted ground. The torso pitch angle must compensate for the ground slope: on uphill slopes, lean forward; on downhill slopes, lean back. The adjustment keeps the CoM projection within the support polygon despite the tilted support surface.</p>
<p>Step-to-step adaptation updates the plan based on feedback. If the robot deviates from the planned trajectory due to terrain irregularities, subsequent steps are adjusted to compensate. If terrain differs significantly from the map, local replanning generates new footsteps using updated terrain information.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="conceptual-diagrams">Conceptual Diagrams<a href="#conceptual-diagrams" class="hash-link" aria-label="Direct link to Conceptual Diagrams" title="Direct link to Conceptual Diagrams" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="gait-cycle-phases">Gait Cycle Phases<a href="#gait-cycle-phases" class="hash-link" aria-label="Direct link to Gait Cycle Phases" title="Direct link to Gait Cycle Phases" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Complete Gait Cycle (One Full Cycle = Right Heel Strike to Right Heel Strike)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Right Leg:  |----STANCE PHASE----|----SWING PHASE----|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Left Leg:   |--SWING--|--STANCE PHASE----|--SWING--|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Detailed Phases:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Double     Single      Double    Single      Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Support    Support     Support   Support     Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|  DS1  |    SS1    |   DS2   |    SS2    |   DS3  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|       |           |         |           |        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">v       v           v         v           v        v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RHS    LTO         LHS       RTO         RHS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(Right (Left       (Left     (Right      (Right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Heel   Toe-off)    Heel      Toe-off)    Heel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Strike)            Strike)               Strike)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DS = Double Support (both feet on ground, weight transfer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SS = Single Support (one foot on ground, other swinging)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RHS/LHS = Right/Left Heel Strike</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RTO/LTO = Right/Left Toe Off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Typical timing (1.0 sec gait cycle):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- DS1: 0.0-0.1 sec (10%)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- SS1: 0.1-0.5 sec (40%)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- DS2: 0.5-0.6 sec (10%)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- SS2: 0.6-1.0 sec (40%)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="static-vs-dynamic-balance">Static vs Dynamic Balance<a href="#static-vs-dynamic-balance" class="hash-link" aria-label="Direct link to Static vs Dynamic Balance" title="Direct link to Static vs Dynamic Balance" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">STATIC BALANCE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |          Support Polygon (top view)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |          +-------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     | CoM      |      [ ]CoM       |  &lt;-- CoM projection inside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |          |                   |      polygon = Static Stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     v          +-------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Ground       Left Foot   Right Foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If CoM moves slowly (quasi-static), remains stable.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DYNAMIC BALANCE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |           Support Polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |           +------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     | CoM       |      |    [ ]CoM  &lt;-- CoM projection OUTSIDE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     |           |      |            but momentum carries forward</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     v           +------+            until next foot lands</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Ground      Right Foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         (next instant)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         +------+    +------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             [ ]CoM  |      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         +------+    +------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       Right Foot  Left Foot (just landed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Walking = Controlled dynamic instability + recovery</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="zero-moment-point-illustration">Zero Moment Point Illustration<a href="#zero-moment-point-illustration" class="hash-link" aria-label="Direct link to Zero Moment Point Illustration" title="Direct link to Zero Moment Point Illustration" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Side View of Walking Robot:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           CoM (center of mass)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /|\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           / | \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          /  |  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Torso   |   Arms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           /|\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          / | \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         /  |  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Leg1   |   Leg2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       |   |   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       |   v   |     &lt;-- ZMP (point where moment = 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ===|===X===|=======  Ground</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       |       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Foot1    Foot2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ZMP Calculation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Sum all gravitational forces on each link</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Sum all inertial forces (mass * acceleration) on each link</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Find point where these create zero net moment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ZMP Stability Criterion:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Support Polygon (top view):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                         |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|        X (ZMP)          |  &lt;-- ZMP inside = Stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                         |      Can maintain this motion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Left Foot        Right Foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+--------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|        |      X (ZMP)     &lt;-- ZMP outside = Unstable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+--------+                     Robot will tip over</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="linear-inverted-pendulum-model-lipm">Linear Inverted Pendulum Model (LIPM)<a href="#linear-inverted-pendulum-model-lipm" class="hash-link" aria-label="Direct link to Linear Inverted Pendulum Model (LIPM)" title="Direct link to Linear Inverted Pendulum Model (LIPM)" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Simplified Model for Walking Analysis:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      * m (point mass - entire robot CoM)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      | length h (constant height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      O (massless rod)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    / | (can tilt in any direction)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   /  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  /   v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">=========== Ground (ZMP can move along ground)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Dynamics (horizontal x direction):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_ddot = (g/h) * (x - x_zmp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Where:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- x = CoM horizontal position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- x_zmp = ZMP horizontal position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- h = CoM height (constant)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- g = gravity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Key insight:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- If ZMP ahead of CoM -&gt; CoM accelerates forward</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- If ZMP behind CoM -&gt; CoM accelerates backward</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Control ZMP to control CoM motion</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="capture-point-concept">Capture Point Concept<a href="#capture-point-concept" class="hash-link" aria-label="Direct link to Capture Point Concept" title="Direct link to Capture Point Concept" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Current State:              Can Stop Here?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  CoM at x_com              CP = x_com + x_dot/omega</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  velocity x_dot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        --&gt;                      Support Polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         [ ]CoM                  +--------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 |    X CP|  &lt;-- CP inside = YES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 +--------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           Can step to CP and stop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Unstable State:             Cannot Stop!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  High velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ----&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [ ]CoM              CP far ahead</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                          +--------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                          |        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                          +--------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                    X CP &lt;-- outside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Must take multiple steps to stabilize.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Step toward CP at each step.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Recovery Strategy:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. Compute CP = CoM_xy + velocity_xy / omega</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. If CP outside support, step toward it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. Repeat until CP converges inside support</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="walking-pattern-generation-flow">Walking Pattern Generation Flow<a href="#walking-pattern-generation-flow" class="hash-link" aria-label="Direct link to Walking Pattern Generation Flow" title="Direct link to Walking Pattern Generation Flow" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">High-Level Plan</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (desired velocity, direction)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Footstep Planning |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (footstep positions, timing)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| ZMP Reference         |  (where ZMP should be each instant)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Generation            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (ZMP reference trajectory)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| CoM Trajectory         |  (use Preview Control or MPC)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Generation             |  (what CoM motion produces this ZMP?)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (CoM trajectory)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Swing Foot Trajectory   |  (how swing foot moves through air)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Generation              |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (CoM + swing foot + stance foot targets)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+---------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Whole-Body Inverse        |  (what joint angles achieve these?)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Kinematics                |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+---------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (joint angle trajectories)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Joint Position Control      |  (track these angles with motors)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-----------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Actual Robot Motion</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="model-predictive-control-architecture">Model Predictive Control Architecture<a href="#model-predictive-control-architecture" class="hash-link" aria-label="Direct link to Model Predictive Control Architecture" title="Direct link to Model Predictive Control Architecture" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Current State (measured)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (CoM pos/vel, feet positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| MPC Optimization       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| Horizon: N steps ahead |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+------------------------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | Optimize over:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - Future footstep locations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - CoM trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | Subject to:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - LIPM dynamics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - ZMP in support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - Kinematic constraints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | Minimize:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - Velocity tracking error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | - Control effort</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Optimal Control Sequence</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | (apply only FIRST control action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Robot Executes One Step</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | Measure new state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(Repeat MPC optimization with updated state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Receding Horizon:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Time:  0    1    2    3    4    5    6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Plan:  |====OPTIMIZE N STEPS====&gt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Execute: X   (only first step)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Time:      1    2    3    4    5    6    7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Plan:      |====OPTIMIZE N STEPS====&gt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Execute:    X   (only first step)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(Horizon &quot;recedes&quot; as robot advances)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="terrain-adaptation-1">Terrain Adaptation<a href="#terrain-adaptation-1" class="hash-link" aria-label="Direct link to Terrain Adaptation" title="Direct link to Terrain Adaptation" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Flat Ground Walking:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">======================  (constant CoM height h)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ---  [ ]CoM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /     \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /       \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">======================  Ground (z = 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stepping Up:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           [ ]CoM        (CoM rises to maintain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          /   \           height above new stance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         /     \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /   =====#####   Step (height delta_z)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /   ====#####</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /  ====#####</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">========#####</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Step up:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - Swing leg lifts higher (clearance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - Stance leg extends to push CoM up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - CoM height relative to stance maintained</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Sloped Ground:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              [ ]CoM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         Torso / | \ (tilted to compensate slope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              /  |  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             /   |   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /    |    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           /     |     \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ==============</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /  Slope angle θ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ==/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Compensation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Torso pitch = -θ (lean into slope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Keeps CoM projection in support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Adjust ZMP calculations to sloped plane</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="fall-detection-and-recovery-1">Fall Detection and Recovery<a href="#fall-detection-and-recovery-1" class="hash-link" aria-label="Direct link to Fall Detection and Recovery" title="Direct link to Fall Detection and Recovery" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">FALL DETECTION INDICATORS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. ZMP Approaching Boundary:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   +----------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |        X-| &lt;-- ZMP near edge (warning!)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   +----------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. High CoM Velocity:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ---&gt;--&gt;  [ ]CoM  (excessive momentum)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. Capture Point Outside:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   +----------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |          |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   +----------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              X CP (cannot stop!)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. Torso Tilt Excessive:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /  [ ]  (tilted beyond threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RECOVERY STRATEGIES:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Mild: Adjust CoM Trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [ ]CoM --adjust--&gt;  [ ]CoM  (shift back toward center)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Moderate: Rapid Stepping to CP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [ ]CoM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --&gt;      (step)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             +------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             |  X CP|  (new support at CP)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             +------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Severe: Protective Falling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [ ]CoM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   v  (lower CoM, extend arms, absorb impact)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  \|/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">===X=== (minimize damage)</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="knowledge-checkpoint">Knowledge Checkpoint<a href="#knowledge-checkpoint" class="hash-link" aria-label="Direct link to Knowledge Checkpoint" title="Direct link to Knowledge Checkpoint" translate="no">​</a></h2>
<p>Test your understanding of bipedal locomotion and balance:</p>
<ol>
<li class="">
<p><strong>Gait Phases</strong>: During the double support phase of walking, both feet are on the ground. Explain why this phase provides more stability than single support, and why humans shorten double support duration when walking faster.</p>
</li>
<li class="">
<p><strong>Static vs Dynamic Balance</strong>: A humanoid robot walks forward with its center of mass projection briefly exiting the support polygon. Explain why this doesn&#x27;t necessarily mean the robot will fall, using the concept of dynamic balance.</p>
</li>
<li class="">
<p><strong>ZMP Computation</strong>: The ZMP formula includes both gravitational terms and inertial (acceleration) terms. Explain why a stationary robot&#x27;s ZMP equals its CoM projection, but a moving robot&#x27;s ZMP differs from its CoM projection.</p>
</li>
<li class="">
<p><strong>ZMP Stability Criterion</strong>: If a walking controller computes a planned trajectory and finds the ZMP reaches the support polygon boundary during single support, what are three possible modifications to make the trajectory stable?</p>
</li>
<li class="">
<p><strong>Center of Pressure vs ZMP</strong>: Explain the relationship between CoP (measured from force sensors) and ZMP (computed from dynamics). Under what conditions are they equal? When do they differ?</p>
</li>
<li class="">
<p><strong>LIPM Dynamics</strong>: The Linear Inverted Pendulum Model equation x_ddot = (g/h) * (x - x_zmp) shows that CoM acceleration depends on the CoM-ZMP distance. If the ZMP is ahead of the CoM, which direction does the CoM accelerate? Why does this make intuitive sense?</p>
</li>
<li class="">
<p><strong>Preview Control</strong>: Walking pattern generation using preview control looks ahead at future footstep locations. Explain why this preview is necessary—why can&#x27;t the controller simply react to the current footstep location?</p>
</li>
<li class="">
<p><strong>Capture Point</strong>: A humanoid in single support receives a push that adds velocity to its CoM. Explain how the Capture Point changes in response to this disturbance, and describe the recovery strategy.</p>
</li>
<li class="">
<p><strong>Kinematic Redundancy in Walking</strong>: A humanoid leg typically has 6 DOF, which exactly suffices to position and orient the foot (6 constraints). During walking, the foot position is constrained by the planned footstep. How can the robot still have freedom to adjust the CoM height?</p>
</li>
<li class="">
<p><strong>MPC for Walking</strong>: Model Predictive Control solves an optimization at each control cycle. Explain why MPC is more computationally expensive than feedforward pattern generation, yet is increasingly used on real humanoid robots.</p>
</li>
<li class="">
<p><strong>Swing Foot Trajectory</strong>: Why do swing foot trajectories typically use higher-order polynomials (5th order or higher) rather than simple straight-line paths between lift-off and landing positions?</p>
</li>
<li class="">
<p><strong>Terrain Adaptation</strong>: When walking uphill on a slope, the robot must lean forward to maintain balance. Explain this using the ZMP stability criterion and how the support polygon orientation changes on sloped ground.</p>
</li>
<li class="">
<p><strong>Underactuation</strong>: During single support, explain why the humanoid robot is underactuated and how this underactuation constrains the walking controller&#x27;s ability to track arbitrary CoM trajectories.</p>
</li>
<li class="">
<p><strong>Fall Recovery</strong>: Describe the trade-offs between three fall recovery strategies: (1) ankle torque modulation, (2) hip/torso adjustment, and (3) rapid stepping. Consider response time, authority, and complexity.</p>
</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="chapter-summary">Chapter Summary<a href="#chapter-summary" class="hash-link" aria-label="Direct link to Chapter Summary" title="Direct link to Chapter Summary" translate="no">​</a></h2>
<p>This chapter examined the complex problem of bipedal locomotion, exploring how humanoid robots walk while maintaining balance against gravity and inertial forces. We began with the fundamental structure of walking: the gait cycle with its alternating stance and swing phases, double support periods for stable weight transfer, and the distinction between static and dynamic balance.</p>
<p>The Zero Moment Point emerged as the central concept for analyzing and ensuring walking stability. ZMP represents the point where moments from gravity and inertial forces cancel, and its location relative to the support polygon determines whether the robot can maintain balance. We developed the mathematical foundation for computing ZMP from the robot&#x27;s dynamic state and established the stability criterion: ZMP must remain within the support polygon.</p>
<p>Walking pattern generation transforms desired walking velocity and direction into detailed joint trajectories. The Linear Inverted Pendulum Model provides a simplified but tractable representation of walking dynamics, enabling analytical solutions and efficient computation. Preview control uses LIPM dynamics to generate CoM trajectories that maintain ZMP within bounds while smoothly tracking reference trajectories derived from planned footsteps.</p>
<p>Advanced concepts extended basic ZMP walking. The Capture Point characterizes global stability and provides intuitive stepping strategies for disturbance rejection: step toward the CP to arrest unwanted motion. Orbital stability analysis determines whether walking patterns are inherently stable across multiple steps. Model Predictive Control optimizes future motion in real-time, adapting to disturbances and changing objectives while respecting hard constraints.</p>
<p>Practical implementation requires generating complete motion plans spanning multiple abstraction layers: footstep planning determines where to step, CoM and swing foot trajectory generation creates Cartesian motion plans, and whole-body inverse kinematics computes joint angles that achieve these targets while satisfying all constraints. Feedback control compensates for modeling errors and external disturbances through multiple cascaded loops operating at different time scales.</p>
<p>Terrain adaptation extends walking capabilities beyond flat ground. Perception systems map the environment, identifying footholds and obstacles. Footstep planning searches for sequences of stable, reachable footholds. Gait adaptation adjusts body posture, step height, and timing to accommodate slopes, steps, and uneven surfaces. Compliant control allows graceful response to unexpected terrain variations.</p>
<p>Throughout the chapter, the theme of underactuation and constraint management appeared repeatedly. Walking requires maintaining balance as the primary constraint, with all other objectives subordinate. The controller must work within the limited authority provided by contact forces that can only push (not pull) and must remain within friction limits.</p>
<p>The principles and techniques developed here form the foundation for locomotion in humanoid robotics. While research continues to improve robustness, efficiency, and versatility, the core concepts—ZMP stability, dynamic walking, predictive control, and adaptive planning—remain central to state-of-the-art systems.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="further-reading">Further Reading<a href="#further-reading" class="hash-link" aria-label="Direct link to Further Reading" title="Direct link to Further Reading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="foundational-papers">Foundational Papers<a href="#foundational-papers" class="hash-link" aria-label="Direct link to Foundational Papers" title="Direct link to Foundational Papers" translate="no">​</a></h3>
<ol>
<li class="">
<p>Vukobratovic, M., &amp; Borovac, B. (2004). &quot;Zero-Moment Point—Thirty Five Years of its Life.&quot; International Journal of Humanoid Robotics, 1(1), 157-173.</p>
<ul>
<li class="">Historical overview and detailed explanation of ZMP concept by its original developers.</li>
</ul>
</li>
<li class="">
<p>Kajita, S., Kanehiro, F., Kaneko, K., Fujiwara, K., Harada, K., Yokoi, K., &amp; Hirukawa, H. (2003). &quot;Biped Walking Pattern Generation by using Preview Control of Zero-Moment Point.&quot; Proceedings of IEEE International Conference on Robotics and Automation.</p>
<ul>
<li class="">Seminal paper introducing preview control for ZMP-based walking pattern generation.</li>
</ul>
</li>
<li class="">
<p>Pratt, J., Carff, J., Drakunov, S., &amp; Goswami, A. (2006). &quot;Capture Point: A Step toward Humanoid Push Recovery.&quot; Proceedings of IEEE-RAS International Conference on Humanoid Robots.</p>
<ul>
<li class="">Introduction of the Capture Point concept for balance analysis and recovery.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="textbooks-and-comprehensive-resources">Textbooks and Comprehensive Resources<a href="#textbooks-and-comprehensive-resources" class="hash-link" aria-label="Direct link to Textbooks and Comprehensive Resources" title="Direct link to Textbooks and Comprehensive Resources" translate="no">​</a></h3>
<ol start="4">
<li class="">
<p>Kajita, S., Hirukawa, H., Harada, K., &amp; Yokoi, K. (2014). &quot;Introduction to Humanoid Robotics.&quot; Springer.</p>
<ul>
<li class="">Comprehensive coverage of bipedal walking including detailed mathematical derivations and practical implementation.</li>
</ul>
</li>
<li class="">
<p>Westervelt, E. R., Grizzle, J. W., Chevallereau, C., Choi, J. H., &amp; Morris, B. (2007). &quot;Feedback Control of Dynamic Bipedal Robot Locomotion.&quot; CRC Press.</p>
<ul>
<li class="">Advanced treatment of walking dynamics and control using hybrid systems theory.</li>
</ul>
</li>
<li class="">
<p>Goswami, A., &amp; Vadakkepat, P. (Eds.). (2019). &quot;Humanoid Robotics: A Reference.&quot; Springer.</p>
<ul>
<li class="">Multi-volume reference with extensive sections on locomotion, balance, and motion planning.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="model-predictive-control-for-walking-1">Model Predictive Control for Walking<a href="#model-predictive-control-for-walking-1" class="hash-link" aria-label="Direct link to Model Predictive Control for Walking" title="Direct link to Model Predictive Control for Walking" translate="no">​</a></h3>
<ol start="7">
<li class="">
<p>Wieber, P. B. (2006). &quot;Trajectory Free Linear Model Predictive Control for Stable Walking in the Presence of Strong Perturbations.&quot; Proceedings of IEEE-RAS International Conference on Humanoid Robots.</p>
<ul>
<li class="">Early application of MPC to bipedal walking with focus on disturbance rejection.</li>
</ul>
</li>
<li class="">
<p>Herdt, A., Diedam, H., Wieber, P. B., Dimitrov, D., Mombaur, K., &amp; Diehl, M. (2010). &quot;Online Walking Motion Generation with Automatic Footstep Placement.&quot; Advanced Robotics, 24(5-6), 719-737.</p>
<ul>
<li class="">MPC framework that optimizes both CoM trajectory and footstep locations online.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="dynamic-walking-and-limit-cycles">Dynamic Walking and Limit Cycles<a href="#dynamic-walking-and-limit-cycles" class="hash-link" aria-label="Direct link to Dynamic Walking and Limit Cycles" title="Direct link to Dynamic Walking and Limit Cycles" translate="no">​</a></h3>
<ol start="9">
<li class="">
<p>McGeer, T. (1990). &quot;Passive Dynamic Walking.&quot; International Journal of Robotics Research, 9(2), 62-82.</p>
<ul>
<li class="">Foundational work on passive dynamic walkers demonstrating natural gait emergence from mechanical design.</li>
</ul>
</li>
<li class="">
<p>Collins, S., Ruina, A., Tedrake, R., &amp; Wisse, M. (2005). &quot;Efficient Bipedal Robots Based on Passive-Dynamic Walkers.&quot; Science, 307(5712), 1082-1085.</p>
<ul>
<li class="">Demonstrates energy-efficient walking by exploiting natural dynamics.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="terrain-adaptation-and-robust-walking">Terrain Adaptation and Robust Walking<a href="#terrain-adaptation-and-robust-walking" class="hash-link" aria-label="Direct link to Terrain Adaptation and Robust Walking" title="Direct link to Terrain Adaptation and Robust Walking" translate="no">​</a></h3>
<ol start="11">
<li class="">
<p>Deits, R., &amp; Tedrake, R. (2014). &quot;Footstep Planning on Uneven Terrain with Mixed-Integer Convex Optimization.&quot; Proceedings of IEEE-RAS International Conference on Humanoid Robots.</p>
<ul>
<li class="">Optimization-based footstep planning for complex terrain.</li>
</ul>
</li>
<li class="">
<p>Kuindersma, S., Deits, R., Fallon, M., Valenzuela, A., Dai, H., Permenter, F., Koolen, T., Marion, P., &amp; Tedrake, R. (2016). &quot;Optimization-based Locomotion Planning, Estimation, and Control Design for the Atlas Humanoid Robot.&quot; Autonomous Robots, 40(3), 429-455.</p>
<ul>
<li class="">Complete walking system for DARPA Robotics Challenge with terrain adaptation.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="practical-implementation">Practical Implementation<a href="#practical-implementation" class="hash-link" aria-label="Direct link to Practical Implementation" title="Direct link to Practical Implementation" translate="no">​</a></h3>
<ol start="13">
<li class="">
<p>Englsberger, J., Ott, C., &amp; Albu-Schäffer, A. (2015). &quot;Three-Dimensional Bipedal Walking Control Based on Divergent Component of Motion.&quot; IEEE Transactions on Robotics, 31(2), 355-368.</p>
<ul>
<li class="">Practical control framework based on Capture Point (Divergent Component of Motion).</li>
</ul>
</li>
<li class="">
<p>Hopkins, M., Hong, D., &amp; Leonessa, A. (2015). &quot;Compliant Locomotion Using Whole-Body Control and Divergent Component of Motion Tracking.&quot; Proceedings of IEEE International Conference on Robotics and Automation.</p>
<ul>
<li class="">Incorporating compliance and disturbance rejection into walking control.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="software-and-tools">Software and Tools<a href="#software-and-tools" class="hash-link" aria-label="Direct link to Software and Tools" title="Direct link to Software and Tools" translate="no">​</a></h3>
<ol start="15">
<li class="">
<p>OpenHRP3 Documentation: <a href="https://fkanehiro.github.io/openhrp3-doc/en/" target="_blank" rel="noopener noreferrer" class="">https://fkanehiro.github.io/openhrp3-doc/en/</a></p>
<ul>
<li class="">Open-source humanoid robotics platform including walking pattern generation tools.</li>
</ul>
</li>
<li class="">
<p>TOWR (Trajectory Optimizer for Walking Robots): <a href="https://github.com/ethz-adrl/towr" target="_blank" rel="noopener noreferrer" class="">https://github.com/ethz-adrl/towr</a></p>
<ul>
<li class="">Modern optimization-based locomotion library with clear documentation.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="online-courses-and-lectures">Online Courses and Lectures<a href="#online-courses-and-lectures" class="hash-link" aria-label="Direct link to Online Courses and Lectures" title="Direct link to Online Courses and Lectures" translate="no">​</a></h3>
<ol start="17">
<li class="">
<p>Underactuated Robotics (MIT 6.832): <a href="http://underactuated.mit.edu/" target="_blank" rel="noopener noreferrer" class="">http://underactuated.mit.edu/</a></p>
<ul>
<li class="">Course by Russ Tedrake covering dynamics, control, and planning for underactuated systems including bipeds.</li>
</ul>
</li>
<li class="">
<p>Bipedal Locomotion lectures from CMU Robotics Institute: Available on YouTube and course websites.</p>
<ul>
<li class="">Comprehensive lecture series covering theory and implementation.</li>
</ul>
</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="looking-ahead">Looking Ahead<a href="#looking-ahead" class="hash-link" aria-label="Direct link to Looking Ahead" title="Direct link to Looking Ahead" translate="no">​</a></h2>
<p>Having mastered bipedal locomotion, we now turn our attention to the upper body: manipulation and grasping. Chapter 13 explores how humanoid robots use their hands and arms to interact with objects in their environment, complementing their walking capabilities with dexterous manipulation.</p>
<p>Manipulation builds on the kinematic and dynamic foundations established in Chapter 11, applying inverse kinematics to reach targets and dynamic models to predict manipulation forces. Just as walking required managing the center of mass for balance, manipulation requires managing contact forces and grasp stability to prevent objects from slipping or being damaged.</p>
<p>The challenges of manipulation parallel those of walking in interesting ways. Walking must maintain balance while moving—an unstable equilibrium actively controlled. Grasping must maintain force closure while manipulating—preventing object motion through carefully coordinated finger forces. Both domains require managing underactuation: walking through limited foot contact, manipulation through limited fingers relative to object degrees of freedom.</p>
<p>The Zero Moment Point concept in walking finds its analog in grasp stability metrics. Just as ZMP must remain within the support polygon, contact forces must remain within friction cones to prevent slipping. The hierarchical control structures developed for walking—primary balance objectives with secondary motion goals—appear in manipulation as primary grasp maintenance with secondary object manipulation.</p>
<p>Model Predictive Control, which optimized walking trajectories while respecting constraints, extends naturally to manipulation. MPC can plan reach-and-grasp motions that avoid obstacles, respect joint limits, and optimize manipulability. The real-time optimization techniques and computational efficiency considerations carry directly forward.</p>
<p>Beyond individual skills, integrating locomotion and manipulation enables complex behaviors. A humanoid might walk to a location, reach for an object while maintaining balance, grasp it, and carry it while walking. Understanding both domains and their interaction becomes essential for capable humanoid systems.</p>
<p>Chapter 13 will explore hand design principles, grasp taxonomies, force closure theory, and motion planning for manipulation. The mathematical tools and algorithmic approaches developed for walking will prove valuable as we tackle the complementary challenge of dexterous object interaction.</p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chapter 11: Humanoid Robot Kinematics and Dynamics</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-13-manipulation-and-grasping"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Chapter 13: Manipulation and Grasping</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#core-concepts" class="table-of-contents__link toc-highlight">Core Concepts</a><ul><li><a href="#the-gait-cycle-and-walking-phases" class="table-of-contents__link toc-highlight">The Gait Cycle and Walking Phases</a></li><li><a href="#static-versus-dynamic-balance" class="table-of-contents__link toc-highlight">Static versus Dynamic Balance</a></li><li><a href="#center-of-mass-and-center-of-pressure" class="table-of-contents__link toc-highlight">Center of Mass and Center of Pressure</a></li><li><a href="#zero-moment-point-the-fundamental-balance-criterion" class="table-of-contents__link toc-highlight">Zero Moment Point: The Fundamental Balance Criterion</a></li><li><a href="#walking-pattern-generation-using-zmp" class="table-of-contents__link toc-highlight">Walking Pattern Generation Using ZMP</a></li><li><a href="#capture-point-and-orbital-stability" class="table-of-contents__link toc-highlight">Capture Point and Orbital Stability</a></li><li><a href="#model-predictive-control-for-walking" class="table-of-contents__link toc-highlight">Model Predictive Control for Walking</a></li><li><a href="#trajectory-generation-for-bipedal-motion" class="table-of-contents__link toc-highlight">Trajectory Generation for Bipedal Motion</a></li><li><a href="#fall-detection-and-recovery" class="table-of-contents__link toc-highlight">Fall Detection and Recovery</a></li><li><a href="#terrain-adaptation" class="table-of-contents__link toc-highlight">Terrain Adaptation</a></li><li><a href="#the-challenge-of-underactuation" class="table-of-contents__link toc-highlight">The Challenge of Underactuation</a></li></ul></li><li><a href="#practical-understanding" class="table-of-contents__link toc-highlight">Practical Understanding</a><ul><li><a href="#computing-the-zero-moment-point" class="table-of-contents__link toc-highlight">Computing the Zero Moment Point</a></li><li><a href="#generating-walking-patterns-with-preview-control" class="table-of-contents__link toc-highlight">Generating Walking Patterns with Preview Control</a></li><li><a href="#footstep-planning-fundamentals" class="table-of-contents__link toc-highlight">Footstep Planning Fundamentals</a></li><li><a href="#implementing-model-predictive-control" class="table-of-contents__link toc-highlight">Implementing Model Predictive Control</a></li><li><a href="#capture-point-based-stepping-control" class="table-of-contents__link toc-highlight">Capture Point-Based Stepping Control</a></li><li><a href="#swing-foot-trajectory-generation" class="table-of-contents__link toc-highlight">Swing Foot Trajectory Generation</a></li><li><a href="#whole-body-inverse-kinematics-for-walking" class="table-of-contents__link toc-highlight">Whole-Body Inverse Kinematics for Walking</a></li><li><a href="#balance-feedback-control" class="table-of-contents__link toc-highlight">Balance Feedback Control</a></li><li><a href="#handling-uneven-terrain" class="table-of-contents__link toc-highlight">Handling Uneven Terrain</a></li></ul></li><li><a href="#conceptual-diagrams" class="table-of-contents__link toc-highlight">Conceptual Diagrams</a><ul><li><a href="#gait-cycle-phases" class="table-of-contents__link toc-highlight">Gait Cycle Phases</a></li><li><a href="#static-vs-dynamic-balance" class="table-of-contents__link toc-highlight">Static vs Dynamic Balance</a></li><li><a href="#zero-moment-point-illustration" class="table-of-contents__link toc-highlight">Zero Moment Point Illustration</a></li><li><a href="#linear-inverted-pendulum-model-lipm" class="table-of-contents__link toc-highlight">Linear Inverted Pendulum Model (LIPM)</a></li><li><a href="#capture-point-concept" class="table-of-contents__link toc-highlight">Capture Point Concept</a></li><li><a href="#walking-pattern-generation-flow" class="table-of-contents__link toc-highlight">Walking Pattern Generation Flow</a></li><li><a href="#model-predictive-control-architecture" class="table-of-contents__link toc-highlight">Model Predictive Control Architecture</a></li><li><a href="#terrain-adaptation-1" class="table-of-contents__link toc-highlight">Terrain Adaptation</a></li><li><a href="#fall-detection-and-recovery-1" class="table-of-contents__link toc-highlight">Fall Detection and Recovery</a></li></ul></li><li><a href="#knowledge-checkpoint" class="table-of-contents__link toc-highlight">Knowledge Checkpoint</a></li><li><a href="#chapter-summary" class="table-of-contents__link toc-highlight">Chapter Summary</a></li><li><a href="#further-reading" class="table-of-contents__link toc-highlight">Further Reading</a><ul><li><a href="#foundational-papers" class="table-of-contents__link toc-highlight">Foundational Papers</a></li><li><a href="#textbooks-and-comprehensive-resources" class="table-of-contents__link toc-highlight">Textbooks and Comprehensive Resources</a></li><li><a href="#model-predictive-control-for-walking-1" class="table-of-contents__link toc-highlight">Model Predictive Control for Walking</a></li><li><a href="#dynamic-walking-and-limit-cycles" class="table-of-contents__link toc-highlight">Dynamic Walking and Limit Cycles</a></li><li><a href="#terrain-adaptation-and-robust-walking" class="table-of-contents__link toc-highlight">Terrain Adaptation and Robust Walking</a></li><li><a href="#practical-implementation" class="table-of-contents__link toc-highlight">Practical Implementation</a></li><li><a href="#software-and-tools" class="table-of-contents__link toc-highlight">Software and Tools</a></li><li><a href="#online-courses-and-lectures" class="table-of-contents__link toc-highlight">Online Courses and Lectures</a></li></ul></li><li><a href="#looking-ahead" class="table-of-contents__link toc-highlight">Looking Ahead</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Course</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Physical-AI-Humanoid-Robotics/">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-01-introduction-to-physical-ai">Foundations</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://panaversity.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">Panaversity<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://docs.ros.org/en/humble/" target="_blank" rel="noopener noreferrer" class="footer__link-item">ROS 2 Documentation<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://developer.nvidia.com/isaac-ros" target="_blank" rel="noopener noreferrer" class="footer__link-item">NVIDIA Isaac<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/muskaanfayyaz/Physical-AI-Humanoid-Robotics" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Panaversity. Built with Docusaurus.</div></div></div></footer><button class="rag-chatbot-toggle" aria-label="Toggle chatbot">💬</button></div>
</body>
</html>
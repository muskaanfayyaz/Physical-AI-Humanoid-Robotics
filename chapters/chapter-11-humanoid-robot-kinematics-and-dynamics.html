<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-chapters/chapter-11-humanoid-robot-kinematics-and-dynamics" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Chapter 11: Humanoid Robot Kinematics and Dynamics | Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 11: Humanoid Robot Kinematics and Dynamics | Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="Introduction"><meta data-rh="true" property="og:description" content="Introduction"><link data-rh="true" rel="icon" href="/Physical-AI-Humanoid-Robotics/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><link data-rh="true" rel="alternate" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics" hreflang="en"><link data-rh="true" rel="alternate" href="https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Chapter 11: Humanoid Robot Kinematics and Dynamics","item":"https://muskaanfayyaz.github.io/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"}]}</script><link rel="stylesheet" href="/Physical-AI-Humanoid-Robotics/assets/css/styles.a722bc7b.css">
<script src="/Physical-AI-Humanoid-Robotics/assets/js/runtime~main.adb20441.js" defer="defer"></script>
<script src="/Physical-AI-Humanoid-Robotics/assets/js/main.7597ac9a.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Physical-AI-Humanoid-Robotics/"><div class="navbar__logo"><img src="/Physical-AI-Humanoid-Robotics/img/logo-transparent.png" alt="Physical AI Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Physical-AI-Humanoid-Robotics/img/logo-transparent.png" alt="Physical AI Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Physical AI &amp; Humanoid Robotics</b></a><a class="navbar__item navbar__link" href="/Physical-AI-Humanoid-Robotics/">Textbook</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/muskaanfayyaz/Physical-AI-Humanoid-Robotics" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Physical-AI-Humanoid-Robotics/"><span title="About" class="linkLabel_WmDU">About</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-01-introduction-to-physical-ai"><span title="Weeks 1-2: Foundations" class="categoryLinkLabel_W154">Weeks 1-2: Foundations</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-03-introduction-to-ros2"><span title="Weeks 3-5: ROS 2 Fundamentals" class="categoryLinkLabel_W154">Weeks 3-5: ROS 2 Fundamentals</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-06-physics-simulation-with-gazebo"><span title="Weeks 6-7: Simulation" class="categoryLinkLabel_W154">Weeks 6-7: Simulation</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-08-nvidia-isaac-platform"><span title="Weeks 8-10: NVIDIA Isaac Platform" class="categoryLinkLabel_W154">Weeks 8-10: NVIDIA Isaac Platform</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><span title="Weeks 11-12: Humanoid Development" class="categoryLinkLabel_W154">Weeks 11-12: Humanoid Development</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-11-humanoid-robot-kinematics-and-dynamics"><span title="Chapter 11: Humanoid Robot Kinematics and Dynamics" class="linkLabel_WmDU">Chapter 11: Humanoid Robot Kinematics and Dynamics</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"><span title="Chapter 12: Bipedal Locomotion and Balance" class="linkLabel_WmDU">Chapter 12: Bipedal Locomotion and Balance</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-13-manipulation-and-grasping"><span title="Chapter 13: Manipulation and Grasping" class="linkLabel_WmDU">Chapter 13: Manipulation and Grasping</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-14-natural-human-robot-interaction"><span title="Chapter 14: Natural Human-Robot Interaction" class="linkLabel_WmDU">Chapter 14: Natural Human-Robot Interaction</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-15-conversational-robotics"><span title="Week 13: Conversational AI" class="categoryLinkLabel_W154">Week 13: Conversational AI</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-16-sim-to-real-transfer"><span title="Final Weeks: Deployment &amp; Capstone" class="categoryLinkLabel_W154">Final Weeks: Deployment &amp; Capstone</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Physical-AI-Humanoid-Robotics/chapters/appendix-a-hardware-setup-guides"><span title="Reference Materials" class="categoryLinkLabel_W154">Reference Materials</span></a></div></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/Physical-AI-Humanoid-Robotics/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Weeks 11-12: Humanoid Development</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Chapter 11: Humanoid Robot Kinematics and Dynamics</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Chapter 11: Humanoid Robot Kinematics and Dynamics</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" translate="no">​</a></h2>
<p>When a humanoid robot reaches for an object, walks across a room, or maintains balance on uneven terrain, complex mathematical machinery works behind the scenes to translate desired motions into precise motor commands. Understanding how robot joints relate to end-effector positions, how velocities propagate through kinematic chains, and how forces and torques govern motion is fundamental to humanoid robot development.</p>
<p>Kinematics describes the geometry of motion without considering the forces that cause it, while dynamics incorporates mass, inertia, and forces to predict and control actual physical behavior. For humanoid robots with dozens of joints, multiple limbs, and complex interaction with the environment, mastering these concepts becomes critical for achieving coordinated, efficient, and stable motion.</p>
<p>This chapter explores the mathematical foundations that enable humanoid robots to move purposefully through space. We begin with forward kinematics, which computes where the robot&#x27;s limbs are given joint angles, then tackle the inverse problem of determining what joint angles achieve a desired position. We examine how velocities and forces propagate through kinematic chains, address singularities where motion control breaks down, and explore the dynamic equations that relate torques to motion. By understanding these principles, you will grasp how motion planning algorithms, control systems, and physical design choices interact to create capable humanoid platforms.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-concepts">Core Concepts<a href="#core-concepts" class="hash-link" aria-label="Direct link to Core Concepts" title="Direct link to Core Concepts" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-kinematic-problem-space">The Kinematic Problem Space<a href="#the-kinematic-problem-space" class="hash-link" aria-label="Direct link to The Kinematic Problem Space" title="Direct link to The Kinematic Problem Space" translate="no">​</a></h3>
<p>Humanoid robots present a unique kinematic challenge: they possess high degrees of freedom, operate in three-dimensional space, must coordinate multiple limbs simultaneously, and interact with their environment through contacts that change over time. Unlike industrial manipulators with fixed bases, humanoids lack a permanently grounded reference frame, complicating the mathematical description of their configuration.</p>
<p>The configuration space, or C-space, represents all possible robot configurations. For a humanoid with n joints, this space has n dimensions, though constraints like joint limits, collision avoidance, and balance requirements restrict the feasible region. Understanding how to navigate this space efficiently while respecting constraints forms the foundation of motion planning and control.</p>
<p>Kinematic chains connect rigid links through joints, creating a tree-like structure in humanoids. The torso typically serves as the root, with legs, arms, and head branching outward. Each chain has its own forward and inverse kinematic solutions, but achieving coordinated whole-body motion requires considering coupling between chains and managing the overall center of mass.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reference-frames-and-transformations">Reference Frames and Transformations<a href="#reference-frames-and-transformations" class="hash-link" aria-label="Direct link to Reference Frames and Transformations" title="Direct link to Reference Frames and Transformations" translate="no">​</a></h3>
<p>Every point and orientation in robotics must be expressed relative to some reference frame. Humanoids use multiple coordinate systems: a world frame fixed in space, a base frame attached to the robot&#x27;s torso or pelvis, joint frames at each articulation, and end-effector frames at the hands, feet, and head. Transforming quantities between these frames requires homogeneous transformation matrices.</p>
<p>A homogeneous transformation matrix combines rotation and translation in a 4x4 format:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">T = | R  p |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | 0  1 |</span><br></span></code></pre></div></div>
<p>where R is a 3x3 rotation matrix and p is a 3x1 position vector. This compact representation allows chaining transformations through matrix multiplication: if T_AB transforms from frame A to B and T_BC transforms from B to C, then T_AC = T_AB * T_BC transforms directly from A to C.</p>
<p>Rotation representations include rotation matrices, Euler angles, axis-angle notation, and quaternions. Each has advantages and drawbacks. Rotation matrices provide direct transformation but use nine parameters for three degrees of freedom. Euler angles are intuitive but suffer from gimbal lock. Quaternions avoid singularities and interpolate smoothly but are less intuitive. Choosing the appropriate representation depends on the application&#x27;s requirements.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="denavit-hartenberg-parameters">Denavit-Hartenberg Parameters<a href="#denavit-hartenberg-parameters" class="hash-link" aria-label="Direct link to Denavit-Hartenberg Parameters" title="Direct link to Denavit-Hartenberg Parameters" translate="no">​</a></h3>
<p>The Denavit-Hartenberg (DH) convention provides a systematic method for establishing coordinate frames and deriving forward kinematics. It reduces the transformation between adjacent joints to four parameters: link length (a), link twist (alpha), link offset (d), and joint angle (theta). For revolute joints, theta varies while other parameters remain fixed; for prismatic joints, d varies.</p>
<p>Two DH conventions exist: classic (original) and modified (Craig). The classic convention places frame i at joint i+1, while the modified convention places frame i at joint i. The modified convention often simplifies calculations and matches intuition better, making it popular in modern robotics libraries.</p>
<p>Establishing DH frames follows specific rules: the z-axis aligns with the joint axis, the x-axis points along the common normal between consecutive z-axes, and the y-axis completes the right-handed coordinate system. While this process can seem arbitrary, following the systematic procedure ensures consistency and correct transformation matrices.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="kinematic-redundancy">Kinematic Redundancy<a href="#kinematic-redundancy" class="hash-link" aria-label="Direct link to Kinematic Redundancy" title="Direct link to Kinematic Redundancy" translate="no">​</a></h3>
<p>A humanoid arm typically has seven or more degrees of freedom to reach and orient its hand in 3D space, which requires only six degrees of freedom (three for position, three for orientation). This excess, called kinematic redundancy, provides flexibility but complicates inverse kinematics since infinitely many joint configurations can achieve the same end-effector pose.</p>
<p>Redundancy offers significant advantages: avoiding joint limits, navigating around obstacles, optimizing secondary criteria like manipulability or energy efficiency, and continuing operation when one joint fails. However, it requires sophisticated algorithms to select among the infinite solutions, typically by optimizing some criterion while achieving the primary task.</p>
<p>The null space of the Jacobian matrix captures directions in joint space that don&#x27;t affect the end-effector. Motion in this null space allows secondary objectives without disturbing the primary task. For example, an arm can maintain its hand position while adjusting its elbow height to avoid an obstacle or stay far from joint limits.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="dynamic-foundations">Dynamic Foundations<a href="#dynamic-foundations" class="hash-link" aria-label="Direct link to Dynamic Foundations" title="Direct link to Dynamic Foundations" translate="no">​</a></h3>
<p>While kinematics describes motion geometry, dynamics incorporates physical laws to relate forces and torques to accelerations. Newton&#x27;s second law (F = ma) and its rotational equivalent (tau = I * alpha) govern how forces create motion. For humanoid robots with many interconnected bodies, dynamics becomes substantially more complex than for single rigid bodies.</p>
<p>The inertia tensor characterizes how mass distributes within a rigid body, determining its resistance to rotational acceleration. Unlike scalar mass, the inertia tensor is a 3x3 matrix that varies with the chosen reference point and coordinate frame orientation. Computing the overall inertia of a humanoid requires combining individual link inertias through appropriate transformations.</p>
<p>Humanoid dynamics exhibits strong coupling: moving one joint generates forces throughout the robot due to inertial effects. A rapidly accelerating arm creates torques at the shoulder, affects the torso orientation, and can disturb balance. Understanding and accounting for these coupled dynamics enables coordinated motion control and efficient energy usage.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="practical-understanding">Practical Understanding<a href="#practical-understanding" class="hash-link" aria-label="Direct link to Practical Understanding" title="Direct link to Practical Understanding" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="forward-kinematics-from-joints-to-space">Forward Kinematics: From Joints to Space<a href="#forward-kinematics-from-joints-to-space" class="hash-link" aria-label="Direct link to Forward Kinematics: From Joints to Space" title="Direct link to Forward Kinematics: From Joints to Space" translate="no">​</a></h3>
<p>Forward kinematics computes the position and orientation of robot links given joint angles. For a kinematic chain, this involves multiplying transformation matrices from the base to the end-effector. Each matrix represents the transformation due to one joint and link.</p>
<p>Consider a simple two-link planar arm. Link 1 has length L1 and rotates by angle theta1. Link 2 has length L2 and rotates by theta2 relative to link 1. The end-effector position follows directly from trigonometry:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x = L1 * cos(theta1) + L2 * cos(theta1 + theta2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y = L1 * sin(theta1) + L2 * sin(theta1 + theta2)</span><br></span></code></pre></div></div>
<p>For spatial (3D) robots, the mathematics extends to include three rotational degrees of freedom. Using DH parameters, the transformation matrix from joint i to i+1 takes the standard form involving four elementary rotations and translations. The overall forward kinematics chains these matrices: T_0n = T_01 * T_12 * ... * T_(n-1)n.</p>
<p>In humanoid robots, forward kinematics serves multiple purposes beyond computing hand positions. It determines foot placement during walking, tracks head orientation for vision systems, computes the center of mass location for balance control, and provides collision detection by tracking all link positions.</p>
<p>Efficient implementation matters for real-time control. Rather than recomputing all transformations from scratch at each timestep, incremental updates exploit the fact that only one or a few joints typically change between control cycles. Caching intermediate results and updating only affected branches reduces computational burden significantly.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="inverse-kinematics-from-desired-pose-to-joint-angles">Inverse Kinematics: From Desired Pose to Joint Angles<a href="#inverse-kinematics-from-desired-pose-to-joint-angles" class="hash-link" aria-label="Direct link to Inverse Kinematics: From Desired Pose to Joint Angles" title="Direct link to Inverse Kinematics: From Desired Pose to Joint Angles" translate="no">​</a></h3>
<p>Inverse kinematics (IK) solves the reverse problem: given a desired end-effector position and orientation, find joint angles that achieve it. This problem is generally more difficult than forward kinematics. For many robot configurations, no closed-form solution exists, multiple solutions may satisfy the requirements, or the desired pose may be unreachable.</p>
<p>Analytical IK solutions derive explicit formulas for joint angles using geometry and trigonometry. These solutions are fast, exact, and provide all possible configurations. However, they exist only for specific kinematic structures, particularly robots with six degrees of freedom and certain geometric properties like intersecting joint axes or parallel consecutive axes.</p>
<p>For the two-link planar arm, analytical IK uses the law of cosines and inverse trigonometry. Given desired position (x, y), first compute theta2:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cos(theta2) = (x^2 + y^2 - L1^2 - L2^2) / (2 * L1 * L2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">theta2 = atan2(±sqrt(1 - cos^2(theta2)), cos(theta2))</span><br></span></code></pre></div></div>
<p>The ± indicates two solutions: elbow-up and elbow-down configurations. Then compute theta1 using the known theta2. This simple example illustrates solution multiplicity and the need to choose among alternatives.</p>
<p>Numerical IK methods work for any robot structure by iteratively adjusting joint angles to minimize the error between current and desired poses. The Jacobian pseudo-inverse method is popular: at each iteration, compute the Jacobian matrix J relating joint velocities to end-effector velocities, then update joint angles by delta_q = J^+ * delta_x, where J^+ is the pseudo-inverse and delta_x is the pose error.</p>
<p>Numerical methods introduce several considerations. They require an initial guess, may converge to local minima rather than global solutions, can be slow for complex robots, and may produce joint angle trajectories that jump discontinuously between solutions. Damped least squares methods improve numerical stability by adding a damping term that trades exact solution accuracy for smoother behavior near singularities.</p>
<p>Humanoid whole-body IK extends these concepts to handle multiple simultaneous constraints: both feet must maintain contact with the ground, the center of mass must remain over the support polygon, joint limits must be respected, and perhaps the hands must reach target positions simultaneously. This requires solving a constrained optimization problem, often formulated as quadratic programming with equality and inequality constraints.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="jacobian-matrices-and-velocity-kinematics">Jacobian Matrices and Velocity Kinematics<a href="#jacobian-matrices-and-velocity-kinematics" class="hash-link" aria-label="Direct link to Jacobian Matrices and Velocity Kinematics" title="Direct link to Jacobian Matrices and Velocity Kinematics" translate="no">​</a></h3>
<p>The Jacobian matrix J relates joint velocities to end-effector velocities: v = J * q_dot, where v is the end-effector velocity (linear and angular), q_dot is the vector of joint velocities, and J depends on the current joint configuration. Each column of J represents how the end-effector moves when one joint moves while others remain fixed.</p>
<p>Computing the Jacobian involves differentiating forward kinematics with respect to joint angles. For revolute joints, the linear velocity contribution is the cross product of the joint axis with the vector from joint to end-effector. The angular velocity contribution is simply the joint axis direction scaled by joint velocity.</p>
<p>The Jacobian structure reveals important properties. Its rank indicates the number of independent directions the end-effector can move instantaneously. For a six-DOF arm, J should have rank 6 when away from singularities. The null space dimension equals the number of degrees of redundancy. The condition number measures how uniform the robot&#x27;s mobility is across different directions.</p>
<p>In control applications, the Jacobian enables Cartesian velocity control: specify desired end-effector velocities, then compute required joint velocities via q_dot = J^+ * v. The pseudo-inverse J^+ generalizes matrix inversion to rectangular and singular matrices. For redundant robots, it provides the minimum-norm solution, but extended formulas can incorporate secondary objectives through null space projections.</p>
<p>Force relationships follow from the Jacobian transpose: tau = J^T * F, where tau is the vector of joint torques and F is the end-effector force (including torques). This relationship reflects the principle of virtual work: power at joints equals power at the end-effector. The Jacobian transpose maps desired end-effector forces to required joint torques, crucial for force control and gravity compensation.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="singularities-and-their-implications">Singularities and Their Implications<a href="#singularities-and-their-implications" class="hash-link" aria-label="Direct link to Singularities and Their Implications" title="Direct link to Singularities and Their Implications" translate="no">​</a></h3>
<p>Singularities occur when the Jacobian matrix loses rank, meaning the robot cannot instantaneously move in some direction regardless of joint velocities. At singularities, the robot&#x27;s reachable velocity space has reduced dimension, inverse kinematics becomes ill-conditioned, and required joint velocities may become infinite for certain end-effector velocities.</p>
<p>Several singularity types exist. Boundary singularities occur at the workspace edge when the robot is fully extended or retracted. Interior singularities happen within the workspace when certain joint axes align. For example, when the elbow of a three-link planar arm lies on the line connecting the shoulder to the wrist, forward and backward elbow motion produce the same wrist motion.</p>
<p>Detecting singularities involves monitoring the Jacobian&#x27;s determinant or singular values. The manipulability measure, defined as the square root of det(J * J^T), quantifies how far the configuration is from singular. It reaches zero at singularities and achieves maximum values in well-conditioned configurations. Motion planning algorithms often use manipulability as an optimization criterion to maintain distance from singular configurations.</p>
<p>Handling singularities requires different strategies depending on the application. Task planning can avoid singular configurations entirely by selecting alternative paths or intermediate waypoints. Damped least squares IK adds a damping term that gracefully degrades tracking performance near singularities rather than producing unbounded joint velocities. Algorithmic singularities in specific IK formulations can sometimes be resolved by reformulating the problem or switching between multiple IK solutions.</p>
<p>For humanoid robots, singularities pose particular challenges during whole-body tasks. Leg singularities during walking can cause control instability. Arm singularities limit manipulation capability. However, kinematic redundancy often allows reconfiguring the robot to escape singular configurations while maintaining end-effector constraints.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="robot-dynamics-forces-and-motion">Robot Dynamics: Forces and Motion<a href="#robot-dynamics-forces-and-motion" class="hash-link" aria-label="Direct link to Robot Dynamics: Forces and Motion" title="Direct link to Robot Dynamics: Forces and Motion" translate="no">​</a></h3>
<p>Dynamic equations describe how joint torques relate to joint accelerations, accounting for inertia, Coriolis effects, centrifugal forces, and gravity. For a humanoid with n joints, the equations of motion take the form:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tau = M(q) * q_ddot + C(q, q_dot) * q_dot + G(q)</span><br></span></code></pre></div></div>
<p>where tau is the vector of joint torques, M(q) is the n-by-n mass matrix (configuration-dependent inertia), C(q, q_dot) captures Coriolis and centrifugal effects, and G(q) represents gravitational torques. This compact form conceals substantial complexity in computing these matrices.</p>
<p>The mass matrix M is symmetric and positive definite, representing the robot&#x27;s resistance to acceleration. Its diagonal elements indicate how much torque is needed to accelerate each joint when others remain stationary. Off-diagonal elements capture coupling: accelerating joint i requires torque at joint j due to inertial coupling between links.</p>
<p>Coriolis forces arise from the interaction between rotation and linear motion. When a link rotates while mass moves along it, Coriolis forces perpendicular to both the rotation axis and the motion direction result. Centrifugal forces push outward from rotation centers. Together, these velocity-dependent terms can be substantial during rapid motion and must be compensated for accurate trajectory tracking.</p>
<p>Gravitational torques depend on link masses, center-of-mass locations, and current configuration. A horizontal arm requires constant torque to support its weight against gravity, while a vertical arm needs no gravity compensation torque. Computing G(q) involves summing the gravitational forces on all links and mapping them to joint torques through the Jacobian transpose.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="newton-euler-formulation">Newton-Euler Formulation<a href="#newton-euler-formulation" class="hash-link" aria-label="Direct link to Newton-Euler Formulation" title="Direct link to Newton-Euler Formulation" translate="no">​</a></h3>
<p>The Newton-Euler recursive formulation computes dynamic equations efficiently by propagating velocities, accelerations, and forces through the kinematic tree. It consists of two passes: a forward pass from base to end-effector propagating velocities and accelerations, and a backward pass from end-effector to base propagating forces and torques.</p>
<p>In the forward pass, each link&#x27;s linear and angular velocities and accelerations are computed from the previous link&#x27;s quantities plus the contribution from the connecting joint. For link i connected by a revolute joint with axis z_i and velocity theta_dot_i:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">omega_i = omega_(i-1) + theta_dot_i * z_i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">omega_dot_i = omega_dot_(i-1) + theta_ddot_i * z_i + omega_(i-1) × (theta_dot_i * z_i)</span><br></span></code></pre></div></div>
<p>The linear acceleration includes both the propagated acceleration and the centrifugal/Coriolis terms from rotation.</p>
<p>The backward pass applies Newton&#x27;s and Euler&#x27;s equations to each link to compute the forces and torques it exerts on its predecessor. Starting from the end-effector (with known external forces), forces and torques propagate backward. The joint torque equals the component of the propagated torque along the joint axis.</p>
<p>This recursive formulation has O(n) computational complexity, substantially more efficient than the O(n^4) naive approach of symbolically deriving equations of motion. Modern implementations optimize further through parallel computation and exploiting problem structure.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lagrangian-formulation">Lagrangian Formulation<a href="#lagrangian-formulation" class="hash-link" aria-label="Direct link to Lagrangian Formulation" title="Direct link to Lagrangian Formulation" translate="no">​</a></h3>
<p>The Lagrangian approach derives equations of motion from energy principles. Define the Lagrangian L as kinetic energy K minus potential energy P: L = K - P. The Euler-Lagrange equation states:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">d/dt(dL/dq_dot) - dL/dq = tau</span><br></span></code></pre></div></div>
<p>Applied to each joint, this yields the full dynamic equations. The mass matrix M emerges from second derivatives of kinetic energy with respect to joint velocities. Coriolis and centrifugal terms come from first derivatives. Gravity terms arise from potential energy derivatives.</p>
<p>Computing kinetic energy requires summing contributions from all links. Each link&#x27;s kinetic energy includes translational and rotational components:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">K_i = (1/2) * m_i * v_i^T * v_i + (1/2) * omega_i^T * I_i * omega_i</span><br></span></code></pre></div></div>
<p>where m_i is link mass, v_i is center-of-mass velocity, omega_i is angular velocity, and I_i is the inertia tensor. Expressing these quantities in terms of joint positions and velocities, then differentiating, yields the equations of motion.</p>
<p>The Lagrangian formulation provides elegant mathematical structure and systematically handles constraints through Lagrange multipliers. It&#x27;s particularly useful for deriving symbolic equations for small systems or analyzing theoretical properties. However, for numerical computation in real-time control, the Newton-Euler recursion is generally more efficient.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="torque-requirements-and-motor-sizing">Torque Requirements and Motor Sizing<a href="#torque-requirements-and-motor-sizing" class="hash-link" aria-label="Direct link to Torque Requirements and Motor Sizing" title="Direct link to Torque Requirements and Motor Sizing" translate="no">​</a></h3>
<p>Understanding dynamics enables sizing motors appropriately. Required torque at each joint depends on the loads it must accelerate, the robot&#x27;s weight distribution, and the desired motion profiles. Undersized motors cannot achieve desired performance; oversized motors waste power, money, and payload capacity.</p>
<p>Peak torque requirements occur during maximum acceleration, rapid direction changes, or when supporting heavy loads far from joints. For a humanoid arm lifting an object, the shoulder must provide torque to accelerate the arm&#x27;s mass, overcome gravity acting on the horizontal moment arm, and accelerate the payload. These components sum directly:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tau_total = tau_inertial + tau_gravity + tau_payload</span><br></span></code></pre></div></div>
<p>Dynamic simulation with representative task scenarios reveals actual torque requirements. Simulate reaching motions at maximum speed, lifting maximum expected payloads, and rapid obstacle avoidance maneuvers. Record peak torques at each joint across all scenarios. Add safety margins (typically 20-50%) to account for modeling uncertainties and unanticipated situations.</p>
<p>Motor selection involves trade-offs between torque, speed, weight, and efficiency. High-torque motors are typically heavy. Gear reduction increases torque at the expense of speed and introduces backlash and friction. Harmonic drives provide high ratios in compact packages but cost significantly more than planetary gears. Brushless DC motors offer good power density and controllability but require more sophisticated drive electronics than brushed motors.</p>
<p>Thermal considerations matter for continuous operation. Motors dissipate power as heat based on current squared times winding resistance. Peak torque ratings apply for short durations; continuous ratings are substantially lower. Humanoid robots performing prolonged tasks must respect continuous limits or provide active cooling.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="computational-tools-and-libraries">Computational Tools and Libraries<a href="#computational-tools-and-libraries" class="hash-link" aria-label="Direct link to Computational Tools and Libraries" title="Direct link to Computational Tools and Libraries" translate="no">​</a></h3>
<p>Several well-established libraries compute kinematics and dynamics for robot systems. The Kinematics and Dynamics Library (KDL), part of the Orocos project, provides a C++ implementation with Python bindings. It handles kinematic chains and trees, computes forward and inverse kinematics using various solvers, and calculates dynamic quantities through recursive Newton-Euler algorithms.</p>
<p>The Rigid Body Dynamics Library (RBDL) offers efficient dynamics computation optimized for control applications. It implements multiple algorithms for forward dynamics (computing accelerations from torques), inverse dynamics (computing torques from desired accelerations), and their Jacobians. Particular attention to numerical efficiency makes RBDL suitable for model predictive control where dynamics must be evaluated thousands of times per second.</p>
<p>Pinocchio, developed by the Gepetto team, provides state-of-the-art performance for rigid body dynamics. It exploits spatial algebra and Lie group structure to achieve exceptional computational efficiency. Pinocchio supports various kinematic representations, computes analytical derivatives of dynamic quantities (crucial for optimization-based control), and interfaces naturally with modern optimal control frameworks.</p>
<p>These libraries share common abstractions: a robot model defined by links, joints, and their parameters; functions to compute forward kinematics, Jacobians, and dynamics; and utilities for parsing standard formats like URDF (Unified Robot Description Format). They differ in implementation language, computational efficiency, breadth of algorithms, and interface design.</p>
<p>Understanding the concepts behind these libraries enables effective use and debugging. When an IK solver fails to converge, recognizing singular configurations suggests modifying the target pose or initial guess. When simulated torques exceed hardware limits, dynamic analysis reveals whether the problem lies in excessive acceleration, insufficient gear reduction, or supporting weight far from joints.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="whole-body-dynamics-and-contact-constraints">Whole-Body Dynamics and Contact Constraints<a href="#whole-body-dynamics-and-contact-constraints" class="hash-link" aria-label="Direct link to Whole-Body Dynamics and Contact Constraints" title="Direct link to Whole-Body Dynamics and Contact Constraints" translate="no">​</a></h3>
<p>Humanoid robots interact with their environment through contacts: feet on the ground, hands grasping objects, or potentially the torso against a wall. These contacts create kinematic constraints (the foot cannot penetrate the floor) and force constraints (the contact can only push, not pull). Incorporating contact constraints into dynamics requires careful mathematical treatment.</p>
<p>Contact models range from simple to sophisticated. Hard contacts treat the constraint as perfectly rigid: contact points have zero acceleration perpendicular to the contact surface. Soft contacts model compliance with spring-damper systems, allowing some penetration. Hybrid models switch between contact and non-contact based on computed forces and positions.</p>
<p>The equations of motion with contacts include constraint forces. In Lagrangian mechanics, these appear as:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">M(q) * q_ddot + C(q, q_dot) * q_dot + G(q) = tau + J_c^T * lambda</span><br></span></code></pre></div></div>
<p>where J_c is the constraint Jacobian and lambda represents contact forces. The constraint equation J_c * q_ddot = 0 (or equals acceleration of the contact surface for non-stationary contacts) must be satisfied. Together, these form a differential-algebraic equation system.</p>
<p>Solving constrained dynamics involves computing both the motion q_ddot and the constraint forces lambda simultaneously. For hard contacts, substituting the constraint equation into the equations of motion yields a reduced system. For soft contacts, the contact forces are explicit functions of penetration depth and velocity, avoiding the algebraic constraints.</p>
<p>Walking robots alternate between different contact configurations: single support when one foot is on the ground, double support when both feet contact, and flight phase when neither foot touches (if running or jumping). Each configuration has different constraint Jacobians and requires different dynamic equations. Transitioning between configurations creates discrete events that hybrid system models capture.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="computational-efficiency-and-real-time-performance">Computational Efficiency and Real-Time Performance<a href="#computational-efficiency-and-real-time-performance" class="hash-link" aria-label="Direct link to Computational Efficiency and Real-Time Performance" title="Direct link to Computational Efficiency and Real-Time Performance" translate="no">​</a></h3>
<p>Real-time control of humanoid robots demands computing kinematics and dynamics within tight time constraints, typically 1 millisecond or less per control cycle. A 30-joint humanoid poses substantial computational challenges. The full mass matrix contains 900 elements, and naively computing them requires thousands of arithmetic operations.</p>
<p>Exploiting problem structure dramatically improves efficiency. The mass matrix is sparse for tree-structured robots; most links don&#x27;t directly couple. Recursive algorithms compute only necessary elements. When joint angles change slightly between timesteps, perturbation methods update quantities incrementally rather than recomputing from scratch.</p>
<p>Symbolic code generation can achieve exceptional efficiency. Rather than general-purpose dynamic algorithms that work for any robot, generate specialized code for one robot&#x27;s specific kinematic structure and parameters. Computer algebra systems derive and simplify symbolic expressions for M, C, and G, then generate optimized C code. This eliminates unnecessary operations and enables aggressive compiler optimization.</p>
<p>Parallel computation offers additional speedup. Computing dynamics for different kinematic chains simultaneously exploits multi-core processors. GPU acceleration can parallelize operations like matrix multiplication and forward kinematics across many end-effectors or trajectory waypoints. However, the recursive structure of many algorithms limits parallelization opportunities.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="from-theory-to-implementation">From Theory to Implementation<a href="#from-theory-to-implementation" class="hash-link" aria-label="Direct link to From Theory to Implementation" title="Direct link to From Theory to Implementation" translate="no">​</a></h3>
<p>Implementing kinematics and dynamics in a real humanoid system requires bridging multiple abstraction layers. At the highest level, task planning specifies desired end-effector trajectories or contact sequences. Inverse kinematics converts these to joint-space trajectories. Dynamic models predict required torques. Low-level control drives motors to track commanded trajectories.</p>
<p>Modeling accuracy matters enormously. Inaccurate inertial parameters cause feedforward torques to miss their targets, requiring feedback control to compensate. Unmodeled friction creates steady-state errors. Joint flexibility not captured in rigid-body models introduces oscillations. System identification procedures measure actual parameters by exciting the robot with known trajectories and fitting models to observed responses.</p>
<p>Kinematic and dynamic models also serve purposes beyond control. Simulation enables testing algorithms before deploying on hardware, reducing risk and development time. State estimation combines noisy sensor measurements with dynamic predictions to produce better estimates of joint positions and velocities. Fault detection compares predicted and actual torques to identify damaged joints or unexpected external forces.</p>
<p>The mathematical foundations covered in this chapter underpin essentially all aspects of humanoid robot development. Motion planning relies on forward kinematics to evaluate candidate trajectories. Optimization-based control requires dynamic gradients. Even learning-based approaches benefit from incorporating kinematic structure into neural network architectures or using model-based rollouts to improve sample efficiency.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="conceptual-diagrams">Conceptual Diagrams<a href="#conceptual-diagrams" class="hash-link" aria-label="Direct link to Conceptual Diagrams" title="Direct link to Conceptual Diagrams" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="forward-kinematics-chain-diagram">Forward Kinematics Chain Diagram<a href="#forward-kinematics-chain-diagram" class="hash-link" aria-label="Direct link to Forward Kinematics Chain Diagram" title="Direct link to Forward Kinematics Chain Diagram" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Base Frame {0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | theta1 (revolute)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Joint 1 ----[Link 1: L1, m1, I1]----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | theta2 (revolute)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Joint 2 ----[Link 2: L2, m2, I2]----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | theta3 (revolute)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End-Effector Frame {3}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Transformation Chain:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T_03 = T_01(theta1) * T_12(theta2) * T_23(theta3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Each T matrix contains:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Rotation from DH parameters (alpha, theta)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Translation from DH parameters (a, d)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="humanoid-kinematic-tree-structure">Humanoid Kinematic Tree Structure<a href="#humanoid-kinematic-tree-structure" class="hash-link" aria-label="Direct link to Humanoid Kinematic Tree Structure" title="Direct link to Humanoid Kinematic Tree Structure" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">                    Head</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   Neck</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Left Arm --- Torso --- Right Arm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (7 DOF)       |        (7 DOF)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Pelvis/Base</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              /      \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             /        \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Left Leg    Right Leg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (6 DOF)     (6 DOF)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Total: ~30+ DOF for typical humanoid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Each limb has own FK/IK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Coupled through torso/pelvis</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="jacobian-velocity-relationship">Jacobian Velocity Relationship<a href="#jacobian-velocity-relationship" class="hash-link" aria-label="Direct link to Jacobian Velocity Relationship" title="Direct link to Jacobian Velocity Relationship" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Joint Space          Jacobian           Task Space</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       (J)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q1_dot              [J11 ... J16]        v_x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q2_dot              [J21 ... J26]        v_y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q3_dot       ---&gt;   [J31 ... J36]  ---&gt;  v_z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q4_dot              [J41 ... J46]        omega_x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q5_dot              [J51 ... J56]        omega_y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">q6_dot              [J61 ... J66]        omega_z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">v = J * q_dot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Dimensions: [6x1] = [6xn] * [nx1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For redundant robots (n &gt; 6):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Infinite solutions exist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Null space allows secondary objectives</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="singularity-configuration-example">Singularity Configuration Example<a href="#singularity-configuration-example" class="hash-link" aria-label="Direct link to Singularity Configuration Example" title="Direct link to Singularity Configuration Example" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Normal Configuration (Non-singular):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    O---\____     Elbow bent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         \    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          \____O  End-effector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Manipulability &gt; 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Can move in all directions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Singular Configuration:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    O---------O---------O  Fully extended</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Manipulability = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cannot move directly toward/away from base</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Joint velocities -&gt; infinity for certain end-effector velocities</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="dynamic-force-propagation">Dynamic Force Propagation<a href="#dynamic-force-propagation" class="hash-link" aria-label="Direct link to Dynamic Force Propagation" title="Direct link to Dynamic Force Propagation" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Backward Force Propagation (Newton-Euler):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End-Effector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | F_ext (external force)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Link n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | F_n, tau_n (computed from F_ext + inertial forces)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Link n-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | F_(n-1), tau_(n-1) (accumulated forces)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Link 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    | F_1, tau_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Base</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Joint Torque = (projected tau along joint axis) + inertial contributions</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="equations-of-motion-components">Equations of Motion Components<a href="#equations-of-motion-components" class="hash-link" aria-label="Direct link to Equations of Motion Components" title="Direct link to Equations of Motion Components" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tau = M(q)*q_ddot + C(q,q_dot)*q_dot + G(q) + tau_ext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">M(q): Mass Matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[m11(q)  m12(q)  ... ]     Configuration-dependent inertia</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[m21(q)  m22(q)  ... ]     Symmetric, positive definite</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[  ...     ...    ... ]     Dimension: n x n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C(q,q_dot): Coriolis/Centrifugal Matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Velocity-dependent forces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Captures interaction between moving joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Dimension: n x n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">G(q): Gravity Vector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[g1(q)]     Gravitational torques at each joint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[g2(q)]     Depends on configuration and link masses</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ ... ]     Dimension: n x 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tau_ext: External Torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Contact forces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Applied loads</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Mapped via Jacobian transpose: J^T * F_external</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="inverse-kinematics-solution-multiplicity">Inverse Kinematics Solution Multiplicity<a href="#inverse-kinematics-solution-multiplicity" class="hash-link" aria-label="Direct link to Inverse Kinematics Solution Multiplicity" title="Direct link to Inverse Kinematics Solution Multiplicity" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Target Position: (x, y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Elbow-Up Solution:        Elbow-Down Solution:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    O                         O----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     \                             \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      \                             \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       \                             O</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        O</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">theta1a, theta2a          theta1b, theta2b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Both reach target!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Selection criteria:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Distance from current configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Joint limit avoidance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Singularity avoidance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Collision avoidance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Manipulability optimization</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="contact-dynamics-diagram">Contact Dynamics Diagram<a href="#contact-dynamics-diagram" class="hash-link" aria-label="Direct link to Contact Dynamics Diagram" title="Direct link to Contact Dynamics Diagram" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Humanoid in Double Support:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [Torso/Mass]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           /    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          /      \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Left Foot]  [Right Foot]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         |            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ========Ground========</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constraints:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Foot positions fixed: p_left = const, p_right = const</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- No penetration: z &gt;= 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Friction cone: |F_tangential| &lt;= mu * F_normal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- No pulling: F_normal &gt;= 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Modified Dynamics:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">M*q_ddot + C*q_dot + G = tau + J_left^T * F_left + J_right^T * F_right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Subject to: J_left * q_ddot = 0, J_right * q_ddot = 0</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="knowledge-checkpoint">Knowledge Checkpoint<a href="#knowledge-checkpoint" class="hash-link" aria-label="Direct link to Knowledge Checkpoint" title="Direct link to Knowledge Checkpoint" translate="no">​</a></h2>
<p>Test your understanding of humanoid kinematics and dynamics with these questions:</p>
<ol>
<li class="">
<p><strong>Forward Kinematics</strong>: Explain how the Denavit-Hartenberg convention reduces the number of parameters needed to describe the transformation between adjacent joint frames. Why are exactly four parameters sufficient?</p>
</li>
<li class="">
<p><strong>Inverse Kinematics</strong>: A 7-DOF humanoid arm must position its hand at a specific point in 3D space without constraining orientation (3 constraints). How many degrees of freedom remain unconstrained? What practical purposes might these extra degrees of freedom serve?</p>
</li>
<li class="">
<p><strong>Jacobian Matrix</strong>: If a 6-DOF arm&#x27;s Jacobian has a very small determinant, what does this indicate about the robot&#x27;s configuration? What practical problems might arise when attempting Cartesian velocity control in this configuration?</p>
</li>
<li class="">
<p><strong>Singularities</strong>: Describe three different strategies for handling kinematic singularities in humanoid motion planning and control. What are the trade-offs of each approach?</p>
</li>
<li class="">
<p><strong>Redundancy Resolution</strong>: For a redundant humanoid arm maintaining its hand position while reaching into a confined space, how would you use null-space motion to avoid obstacles without disturbing the hand?</p>
</li>
<li class="">
<p><strong>Mass Matrix</strong>: Explain why the mass matrix M(q) in the dynamic equations depends on configuration q, even though individual link masses and inertias are constant. Provide an intuitive example.</p>
</li>
<li class="">
<p><strong>Coriolis Forces</strong>: When a humanoid rapidly swings its arm sideways while rotating its torso, significant Coriolis forces arise. Explain the physical origin of these forces and why they must be compensated in the control system.</p>
</li>
<li class="">
<p><strong>Newton-Euler vs Lagrangian</strong>: Compare the computational complexity of the recursive Newton-Euler formulation with direct application of the Lagrangian method. Why is Newton-Euler preferred for real-time control?</p>
</li>
<li class="">
<p><strong>Motor Sizing</strong>: A humanoid&#x27;s shoulder joint must support the arm (mass 3 kg, center of mass 0.3 m from joint) horizontally. Estimate the required torque accounting only for gravity. If the arm must accelerate upward at 5 m/s^2, how does the torque requirement change?</p>
</li>
<li class="">
<p><strong>Contact Constraints</strong>: When a humanoid places both feet flat on the ground, these contacts create kinematic constraints. Explain how these constraints modify the equations of motion and why the system becomes a differential-algebraic equation (DAE).</p>
</li>
<li class="">
<p><strong>Workspace Analysis</strong>: How do joint limits, singularities, and obstacle avoidance each restrict the humanoid arm&#x27;s reachable workspace? Which restriction is kinematic, which is practical, and which is fundamental?</p>
</li>
<li class="">
<p><strong>Whole-Body IK</strong>: When computing inverse kinematics for a humanoid with both feet fixed, both hands reaching targets, and the center of mass constrained over the support polygon, you have more constraints than a single kinematic chain can handle. How would you formulate this as an optimization problem?</p>
</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="chapter-summary">Chapter Summary<a href="#chapter-summary" class="hash-link" aria-label="Direct link to Chapter Summary" title="Direct link to Chapter Summary" translate="no">​</a></h2>
<p>This chapter explored the mathematical foundations governing how humanoid robots move through space and interact with their environment. We began with forward kinematics, which computes end-effector positions from joint angles using transformation matrices and Denavit-Hartenberg parameters. The systematic DH convention reduces each joint transformation to four parameters, enabling compact representation of complex kinematic chains.</p>
<p>Inverse kinematics reverses this process, finding joint angles that achieve desired end-effector poses. We examined both analytical solutions, which provide closed-form answers for specific kinematic structures, and numerical methods like Jacobian pseudo-inverse, which work for general configurations but require iterative solution. The challenge of solution multiplicity and the advantage of kinematic redundancy emerged as key themes.</p>
<p>The Jacobian matrix connects joint velocities to end-effector velocities, enabling Cartesian velocity control and revealing manipulability properties. Singularities occur where the Jacobian loses rank, creating configurations where certain motions become impossible or require infinite joint velocities. Understanding and avoiding singularities is critical for robust motion control.</p>
<p>Robot dynamics incorporates forces and torques, extending purely geometric kinematics to predict actual physical behavior. The equations of motion relate joint torques to accelerations through the configuration-dependent mass matrix, velocity-dependent Coriolis and centrifugal terms, and gravitational torques. Two complementary formulations emerged: the recursive Newton-Euler approach optimized for numerical efficiency, and the energy-based Lagrangian method providing elegant mathematical structure.</p>
<p>Contact constraints fundamentally alter the dynamics, creating differential-algebraic equations where contact forces must be solved simultaneously with motion. Humanoids continuously transition between contact configurations during locomotion, requiring careful handling of hybrid dynamics.</p>
<p>Practical considerations included motor sizing based on dynamic torque requirements, computational efficiency through recursive algorithms and code generation, and leveraging established libraries like KDL, RBDL, and Pinocchio. These tools encapsulate sophisticated algorithms while providing clean interfaces for robot modeling and computation.</p>
<p>The concepts in this chapter form the foundation for essentially all higher-level humanoid capabilities. Motion planning relies on forward kinematics to evaluate trajectories. Control systems use inverse kinematics to translate task specifications into joint commands. Dynamic models enable feedforward control and accurate simulation. Balance and locomotion algorithms fundamentally depend on managing the center of mass and contact forces through dynamic equations.</p>
<p>Mastering kinematics and dynamics provides the mathematical language for reasoning about robot motion and the computational tools for implementing sophisticated behaviors. As humanoid robots take on increasingly complex tasks in unstructured environments, these foundational concepts remain central to achieving capable, robust, and efficient performance.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="further-reading">Further Reading<a href="#further-reading" class="hash-link" aria-label="Direct link to Further Reading" title="Direct link to Further Reading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="foundational-textbooks">Foundational Textbooks<a href="#foundational-textbooks" class="hash-link" aria-label="Direct link to Foundational Textbooks" title="Direct link to Foundational Textbooks" translate="no">​</a></h3>
<ol>
<li class="">
<p>Murray, R. M., Li, Z., &amp; Sastry, S. S. (1994). &quot;A Mathematical Introduction to Robotic Manipulation.&quot; CRC Press.</p>
<ul>
<li class="">Rigorous mathematical treatment using geometric methods, screw theory, and Lie groups. Advanced but provides deep understanding of kinematic foundations.</li>
</ul>
</li>
<li class="">
<p>Siciliano, B., Sciavicco, L., Villani, L., &amp; Oriolo, G. (2009). &quot;Robotics: Modelling, Planning and Control.&quot; Springer.</p>
<ul>
<li class="">Comprehensive coverage of kinematics, dynamics, and control with detailed examples. Excellent balance between theory and application.</li>
</ul>
</li>
<li class="">
<p>Craig, J. J. (2017). &quot;Introduction to Robotics: Mechanics and Control&quot; (4th ed.). Pearson.</p>
<ul>
<li class="">Classic textbook with clear explanations of DH parameters, Jacobians, and dynamics. Includes numerous worked examples and exercises.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="humanoid-specific-resources">Humanoid-Specific Resources<a href="#humanoid-specific-resources" class="hash-link" aria-label="Direct link to Humanoid-Specific Resources" title="Direct link to Humanoid-Specific Resources" translate="no">​</a></h3>
<ol start="4">
<li class="">
<p>Kajita, S., Hirukawa, H., Harada, K., &amp; Yokoi, K. (2014). &quot;Introduction to Humanoid Robotics.&quot; Springer.</p>
<ul>
<li class="">Dedicated to humanoid robots with detailed coverage of kinematics, dynamics, and their application to walking and manipulation.</li>
</ul>
</li>
<li class="">
<p>Goswami, A., &amp; Vadakkepat, P. (Eds.). (2019). &quot;Humanoid Robotics: A Reference.&quot; Springer.</p>
<ul>
<li class="">Multi-volume reference covering all aspects of humanoid robotics, including extensive sections on modeling and control.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="computational-methods">Computational Methods<a href="#computational-methods" class="hash-link" aria-label="Direct link to Computational Methods" title="Direct link to Computational Methods" translate="no">​</a></h3>
<ol start="6">
<li class="">
<p>Featherstone, R. (2014). &quot;Rigid Body Dynamics Algorithms.&quot; Springer.</p>
<ul>
<li class="">Definitive reference on efficient algorithms for computing robot dynamics. Essential for understanding modern implementations.</li>
</ul>
</li>
<li class="">
<p>Park, F. C., &amp; Lynch, K. M. (2017). &quot;Introduction to Robotics: Mechanics, Planning, and Control.&quot; Cambridge University Press.</p>
<ul>
<li class="">Modern approach using product of exponentials formulation and geometric methods. Excellent for understanding alternative kinematics representations.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="software-and-tools-documentation">Software and Tools Documentation<a href="#software-and-tools-documentation" class="hash-link" aria-label="Direct link to Software and Tools Documentation" title="Direct link to Software and Tools Documentation" translate="no">​</a></h3>
<ol start="8">
<li class="">
<p>Pinocchio Documentation: <a href="https://stack-of-tasks.github.io/pinocchio/" target="_blank" rel="noopener noreferrer" class="">https://stack-of-tasks.github.io/pinocchio/</a></p>
<ul>
<li class="">Comprehensive documentation for the high-performance dynamics library, including tutorials and examples.</li>
</ul>
</li>
<li class="">
<p>ROS 2 Control Documentation: <a href="https://control.ros.org/" target="_blank" rel="noopener noreferrer" class="">https://control.ros.org/</a></p>
<ul>
<li class="">Framework documentation showing how kinematics and dynamics integrate into complete robot control systems.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="research-papers">Research Papers<a href="#research-papers" class="hash-link" aria-label="Direct link to Research Papers" title="Direct link to Research Papers" translate="no">​</a></h3>
<ol start="10">
<li class="">
<p>Nakamura, Y. (1991). &quot;Advanced Robotics: Redundancy and Optimization.&quot; Addison-Wesley.</p>
<ul>
<li class="">Foundational work on kinematic redundancy and its exploitation for secondary objectives.</li>
</ul>
</li>
<li class="">
<p>Sentis, L., &amp; Khatib, O. (2005). &quot;Synthesis of Whole-Body Behaviors through Hierarchical Control of Behavioral Primitives.&quot; International Journal of Humanoid Robotics, 2(4), 505-518.</p>
<ul>
<li class="">Influential paper on whole-body control of humanoid robots using operational space formulation.</li>
</ul>
</li>
</ol>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="online-resources">Online Resources<a href="#online-resources" class="hash-link" aria-label="Direct link to Online Resources" title="Direct link to Online Resources" translate="no">​</a></h3>
<ol start="12">
<li class="">
<p>Modern Robotics Specialization (Coursera): Northwestern University course with accompanying textbook and software.</p>
<ul>
<li class="">Free online course covering kinematics, dynamics, and motion planning with excellent visualizations.</li>
</ul>
</li>
<li class="">
<p>Underactuated Robotics (MIT OpenCourseWare): Russ Tedrake&#x27;s course materials on dynamics and control.</p>
<ul>
<li class="">Focuses on underactuated systems including walking robots, with emphasis on dynamic modeling.</li>
</ul>
</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="looking-ahead">Looking Ahead<a href="#looking-ahead" class="hash-link" aria-label="Direct link to Looking Ahead" title="Direct link to Looking Ahead" translate="no">​</a></h2>
<p>With a solid foundation in kinematics and dynamics, we&#x27;re prepared to tackle one of the most challenging aspects of humanoid robotics: bipedal locomotion and balance. Chapter 12 builds directly on the concepts developed here, applying them to the complex problem of walking on two legs.</p>
<p>Walking requires continuous management of the robot&#x27;s dynamics to maintain balance while progressing forward. The Zero Moment Point (ZMP) criterion, which we&#x27;ll explore in depth, uses dynamic equations to ensure the robot won&#x27;t tip over. Center of mass kinematics, computed through forward kinematics of all links, determines whether the robot remains balanced. Trajectory generation creates joint angle profiles that achieve desired foot placements while satisfying dynamic constraints.</p>
<p>The Jacobian matrices we studied enable computing contact forces from joint torques, essential for verifying that the robot can maintain foot contact without slipping. Inverse kinematics translates desired foot and pelvis trajectories into joint commands. Dynamic models predict whether planned motions respect actuator torque limits.</p>
<p>Beyond walking, we&#x27;ll examine how Model Predictive Control uses dynamic models to optimize future trajectories in real-time. The computational efficiency techniques discussed here become critical when dynamics must be evaluated thousands of times per control cycle. Understanding singularities helps explain why certain leg configurations create balance difficulties.</p>
<p>Balance control requires managing the relationship between gravitational forces, inertial forces from motion, and ground reaction forces. The dynamic equations of motion provide the framework for analyzing these forces. Contact dynamics, briefly introduced here, become central to understanding how foot-ground interactions constrain and enable locomotion.</p>
<p>As we progress to manipulation (Chapter 13) and human-robot interaction (Chapter 14), kinematic and dynamic concepts continue to play essential roles. Grasp stability depends on force analysis through contact Jacobians. Compliant control for safe interaction requires accurate dynamic models to predict collision forces. Natural motion generation benefits from understanding the robot&#x27;s kinematic capabilities and limitations.</p>
<p>The mathematical tools developed in this chapter—transformation matrices, Jacobians, dynamic equations—serve as the language in which we express robot capabilities and control objectives. Comfort with these concepts enables understanding advanced research papers, debugging control problems, and designing novel behaviors. The investment in mastering these foundations pays dividends throughout the entire field of humanoid robotics.</p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-10-navigation-and-path-planning"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chapter 10: Navigation and Path Planning</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-12-bipedal-locomotion-and-balance"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Chapter 12: Bipedal Locomotion and Balance</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#core-concepts" class="table-of-contents__link toc-highlight">Core Concepts</a><ul><li><a href="#the-kinematic-problem-space" class="table-of-contents__link toc-highlight">The Kinematic Problem Space</a></li><li><a href="#reference-frames-and-transformations" class="table-of-contents__link toc-highlight">Reference Frames and Transformations</a></li><li><a href="#denavit-hartenberg-parameters" class="table-of-contents__link toc-highlight">Denavit-Hartenberg Parameters</a></li><li><a href="#kinematic-redundancy" class="table-of-contents__link toc-highlight">Kinematic Redundancy</a></li><li><a href="#dynamic-foundations" class="table-of-contents__link toc-highlight">Dynamic Foundations</a></li></ul></li><li><a href="#practical-understanding" class="table-of-contents__link toc-highlight">Practical Understanding</a><ul><li><a href="#forward-kinematics-from-joints-to-space" class="table-of-contents__link toc-highlight">Forward Kinematics: From Joints to Space</a></li><li><a href="#inverse-kinematics-from-desired-pose-to-joint-angles" class="table-of-contents__link toc-highlight">Inverse Kinematics: From Desired Pose to Joint Angles</a></li><li><a href="#jacobian-matrices-and-velocity-kinematics" class="table-of-contents__link toc-highlight">Jacobian Matrices and Velocity Kinematics</a></li><li><a href="#singularities-and-their-implications" class="table-of-contents__link toc-highlight">Singularities and Their Implications</a></li><li><a href="#robot-dynamics-forces-and-motion" class="table-of-contents__link toc-highlight">Robot Dynamics: Forces and Motion</a></li><li><a href="#newton-euler-formulation" class="table-of-contents__link toc-highlight">Newton-Euler Formulation</a></li><li><a href="#lagrangian-formulation" class="table-of-contents__link toc-highlight">Lagrangian Formulation</a></li><li><a href="#torque-requirements-and-motor-sizing" class="table-of-contents__link toc-highlight">Torque Requirements and Motor Sizing</a></li><li><a href="#computational-tools-and-libraries" class="table-of-contents__link toc-highlight">Computational Tools and Libraries</a></li><li><a href="#whole-body-dynamics-and-contact-constraints" class="table-of-contents__link toc-highlight">Whole-Body Dynamics and Contact Constraints</a></li><li><a href="#computational-efficiency-and-real-time-performance" class="table-of-contents__link toc-highlight">Computational Efficiency and Real-Time Performance</a></li><li><a href="#from-theory-to-implementation" class="table-of-contents__link toc-highlight">From Theory to Implementation</a></li></ul></li><li><a href="#conceptual-diagrams" class="table-of-contents__link toc-highlight">Conceptual Diagrams</a><ul><li><a href="#forward-kinematics-chain-diagram" class="table-of-contents__link toc-highlight">Forward Kinematics Chain Diagram</a></li><li><a href="#humanoid-kinematic-tree-structure" class="table-of-contents__link toc-highlight">Humanoid Kinematic Tree Structure</a></li><li><a href="#jacobian-velocity-relationship" class="table-of-contents__link toc-highlight">Jacobian Velocity Relationship</a></li><li><a href="#singularity-configuration-example" class="table-of-contents__link toc-highlight">Singularity Configuration Example</a></li><li><a href="#dynamic-force-propagation" class="table-of-contents__link toc-highlight">Dynamic Force Propagation</a></li><li><a href="#equations-of-motion-components" class="table-of-contents__link toc-highlight">Equations of Motion Components</a></li><li><a href="#inverse-kinematics-solution-multiplicity" class="table-of-contents__link toc-highlight">Inverse Kinematics Solution Multiplicity</a></li><li><a href="#contact-dynamics-diagram" class="table-of-contents__link toc-highlight">Contact Dynamics Diagram</a></li></ul></li><li><a href="#knowledge-checkpoint" class="table-of-contents__link toc-highlight">Knowledge Checkpoint</a></li><li><a href="#chapter-summary" class="table-of-contents__link toc-highlight">Chapter Summary</a></li><li><a href="#further-reading" class="table-of-contents__link toc-highlight">Further Reading</a><ul><li><a href="#foundational-textbooks" class="table-of-contents__link toc-highlight">Foundational Textbooks</a></li><li><a href="#humanoid-specific-resources" class="table-of-contents__link toc-highlight">Humanoid-Specific Resources</a></li><li><a href="#computational-methods" class="table-of-contents__link toc-highlight">Computational Methods</a></li><li><a href="#software-and-tools-documentation" class="table-of-contents__link toc-highlight">Software and Tools Documentation</a></li><li><a href="#research-papers" class="table-of-contents__link toc-highlight">Research Papers</a></li><li><a href="#online-resources" class="table-of-contents__link toc-highlight">Online Resources</a></li></ul></li><li><a href="#looking-ahead" class="table-of-contents__link toc-highlight">Looking Ahead</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Course</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Physical-AI-Humanoid-Robotics/">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/Physical-AI-Humanoid-Robotics/chapters/chapter-01-introduction-to-physical-ai">Foundations</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://panaversity.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">Panaversity<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://docs.ros.org/en/humble/" target="_blank" rel="noopener noreferrer" class="footer__link-item">ROS 2 Documentation<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://developer.nvidia.com/isaac-ros" target="_blank" rel="noopener noreferrer" class="footer__link-item">NVIDIA Isaac<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/muskaanfayyaz/Physical-AI-Humanoid-Robotics" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Panaversity. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>